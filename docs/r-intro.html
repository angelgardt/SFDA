<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>20&nbsp; Основы R – SFDA | PSY HSE</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./r-preproc.html" rel="next">
<link href="./part-r.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-485d01fc63b59abcd3ee1bf1e8e2748d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Ничего не найдено",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Очистить",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Отмена",
    "search-submit-button-title": "Отправить",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./part-r.html">Анализ данных в R</a></li><li class="breadcrumb-item"><a href="./r-intro.html"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Основы R</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">SFDA | PSY HSE</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Начало</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Введение в статистику</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Основания статистики</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro-randvals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Шкалы и&nbsp;случайные величины</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part-desc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Описательная статистика</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desc-centraltend.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Меры центральной тенденции</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desc-variation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Меры разброса</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desc-normdist.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Нормальное распределение</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./desc-ci.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Доверительные интервалы</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part-infer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Статистика вывода</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-stattesting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Тестирование статистических гипотез</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-categorical.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Анализ категориальных данных</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-correlation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Корреляционный анализ</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-anovaI.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Однофакторный дисперсионный анализ</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-anovaII.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Многофакторный дисперсионный анализ</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-posthoc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Post hoc тесты</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-simplelinear.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Простая линейная регрессия</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-multiplelinear.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Множественная линейная регрессия</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-ancova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Ковариационный анализ</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-logreg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Логистическая регрессия</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-cluster.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Кластерный анализ</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-efa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Эксплораторный факторный анализ</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer-cfa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Конфирматорный факторный анализ</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part-r.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Анализ данных в R</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-intro.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Основы R</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-preproc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Предобработка данных</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-vis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Визуализация данных</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-lm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Корреляция и&nbsp;регрессия</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-anova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Дисперсионный анализ</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-glm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Логистическая регрессия</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-cluster.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Кластерный анализ</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-efa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Эксплораторный факторный анализ</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./r-cfa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Конфирматорный факторный анализ</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./outro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">[Не]конец</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Содержание</h2>
   
  <ul>
  <li><a href="#приводим-логические-данные-в-числовым" id="toc-приводим-логические-данные-в-числовым" class="nav-link active" data-scroll-target="#приводим-логические-данные-в-числовым"><span class="header-section-number">21</span> приводим логические данные в числовым</a></li>
  <li><a href="#создадим-список-такой-же-как-l2-только-именованный" id="toc-создадим-список-такой-же-как-l2-только-именованный" class="nav-link" data-scroll-target="#создадим-список-такой-же-как-l2-только-именованный"><span class="header-section-number">22</span> создадим список такой же, как l2, только именованный</a></li>
  <li><a href="#немного-изменим-набор-переменных-для-демонстрации-возможностей" id="toc-немного-изменим-набор-переменных-для-демонстрации-возможностей" class="nav-link" data-scroll-target="#немного-изменим-набор-переменных-для-демонстрации-возможностей"><span class="header-section-number">23</span> немного изменим набор переменных для демонстрации возможностей</a></li>
  <li><a href="#например-можно-прочитать-файл-прямо-из-папки-загрузки" id="toc-например-можно-прочитать-файл-прямо-из-папки-загрузки" class="nav-link" data-scroll-target="#например-можно-прочитать-файл-прямо-из-папки-загрузки"><span class="header-section-number">24</span> например, можно прочитать файл прямо из папки «Загрузки»</a></li>
  <li><a href="#это-ссылка-на-мой-github-где-лежит-нужный-нам-файл" id="toc-это-ссылка-на-мой-github-где-лежит-нужный-нам-файл" class="nav-link" data-scroll-target="#это-ссылка-на-мой-github-где-лежит-нужный-нам-файл"><span class="header-section-number">25</span> это ссылка на мой GitHub, где лежит нужный нам файл</a></li>
  <li><a href="#снова-про-качество-вина" id="toc-снова-про-качество-вина" class="nav-link" data-scroll-target="#снова-про-качество-вина"><span class="header-section-number">26</span> снова про качество вина</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./part-r.html">Анализ данных в R</a></li><li class="breadcrumb-item"><a href="./r-intro.html"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Основы R</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Основы R</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Знакомство с R и RStudio — Я вот не могу выбрать: делать на R или на Python? — Да какая разница! Главное — делай!</p>
<p>Что это и откуда? R — популярный язык программирования среди исследователей в социальных и гуманитарных науках. Если совсем коротко, то начиналось всё с языка S, который был языком программирования для статистического анализа. Потом его доработали и получился R.</p>
<p>Хотя сегодня всё ещё можно услышать, что «R — это язык программирования для статистической обработки данных», это ложь. Да, когда-то давно дела обстояли именно так, но сейчас R — это полноценный язык программирования, который позволяет решать широкий спект задач от статистического анализа и data wrangling до машинного обучения, моделирования и создания сайтов и приложений.</p>
<p>Почему R? свободное ПО (часть GNU Project) динамично развивается громадные возможности расширения функционала более 10 000 пакетов открытый исходный код возможность написать свои пакеты</p>
<p>Source</p>
<p>большое сообщество по всему миру, много ресурсов для задавания вопросов Linear Warriors vs Quadratic Wizards в SPSS (и другие GUI пакеты) ниже порог вхождения, но развитие навыков — линейное в R порог вхождения выше, но впоследствии случается резкий буст, и вы становитесь богами дата саенс</p>
<p>Source</p>
<p>репродуцируемость результатов А он лучше Питона?</p>
<p>Source</p>
<p>Нет. Но он и не хуже.</p>
<p>Вообще файт R vs Python, на мой взгляд, несколько бессмысленный, поскольку, по факту, всё упирается в синтаксис языка. Ну, и запрос работодателя, конечно. Возможности обоих языков и скорость работы сопоставимы. Области применения по большей части тоже. Поэтому я пользуюсь следующей эвристикой:</p>
<p>аналитика, статистика, графики, покрутить данные — R машинное обучение, нейросети, другой ИИ, интерфейсы и [собственно] программирование — Python Многие, наверняка, оспорят такое разделение — я же не стану отстаивать его истинность.</p>
<p>Мы будем работать на R, поскольку он всё же более популярен в наших кругах — среди «социально-гуманитарных аналитиков».</p>
<p>Установка R и RStudio Чтобы нам радостно и приятно жилось, нужно установить:</p>
<p>Сначала R на Windows на Mac на Linux Затем RStudio Если что-то не установилось или вы предпочитаете облачные сервисы, то можно работать через браузер в RStudio Cloud.</p>
<p>А зачем обе штуки ставить? Вопрос не безосновательный. Не углубляясь в мелкие детали, скажем так: R — это собственно язык программирования, а RStudio — это среда (IDE, integrated development environment), которая позволяет в этом языке удобно и просто работать, а также расширяет его возможности.</p>
<p>RStudio — не единственная среда для работы в R, но, определённо, самая топовая. Почти все пользуются именно ею, и нет смысла искать что-то более удобное.</p>
<p>Где спросить вопрос или искать ответ? Google — препарат выбора Stack Overflow — ответы на вопросы, и не только по R Stack Overflow на русском — то же самое, только отечественные специалисты Cookbook for R — хорошая книжка для старта RStudio Community — ответы на вопросы по R R-bloggers — про новинки в R и рядом с ним Хабр про R … Интерфейс RStudio Итак, посмотрим на RStudio. При запуске у вас откроется что-то такое:</p>
<p>Видно четыре (или три1) окна. Давайте последовательно разбираться, что в каждом из них происходит.</p>
<p>Console В консоль можно писать команды и запускать их нажатием Enter. Они будут сразу выполняться. После некоторых команд будет выводиться какой-то результат. С помощью стрелок ↑ и ↓ можно вывести предыдущие команды, например, чтобы запустить их ещё раз, не вводя повторно, или каким-либо образом их изменить.</p>
<p>Можно, в прицнипе, работать только из консоли, но на практике это не очень удобно. Главным образом, из-за того, что команды улетают «вникуда» и к некоторым уже будет нельзя вернуться. Поэтому существует редактор кода.</p>
<p>Code Editor По своей сути это обычный блокнот с той лишь разницей, что здесь некоторые слова раскрашены. И в этом блокноте мы пишем текст программы (скрипт), который состоит из комманд. Чтобы выполнить команду, нам необхожимо отправить её в консоль с помощью Ctrl + Enter (⌘ + Enter). Нажатие Enter здесь как и в обычном текстовом редакторе осуществляет переход на новую строку. Результат выполнения команды отображается в консоли, как будто вы изначально запускали команду там.</p>
<p>В консоли удобно что-то быстро посчитать, скрипт же удобнее при работе с длинными командами и для сохранения кода (текста) для дальнейшей работы. Чтобы сохранить скрипт, сделайте File → Save (as…) или нажмите Ctrl + S (⌘ + S).</p>
<p>Несмотря на то, что файл сохраняется с расширением .R, это всё ещё обычный текст, который можно открыть и редактировать в любом текстовом редакторе (типа Notebook или TextEdit).</p>
<p>Кодировка Компьютер умеет хранить в памяти только цифры. А текст мы набираем буквами. Поэтому ему приходится перекодировать буквы в цифры. Делать это можно по-разному — поэтому существуют разные кодировки.</p>
<p>При сохранении скрипта важно следить за кодировкой, особенно если в тексте встречаются кириллические знаки. В разных операционных систем разная кодировка по умолчанию, поэтому на другом компьютере файл может открываться с неведомой кракозяброй типа этой:</p>
<p>Обычно при сохрании файла с кириллицей программа автоматически спрашивает, в какой кодировке его надо сохранить. Выбирайте UTF-8 — она корректно откроется в любой операционной системе. Также вы можете сохранить файл в определенной кодировке в помощью File → Save with Encoding….</p>
<p>Если при открытии файла у вас отображается кракозябра, подобная той, которая показана выше, нужно узнать кодировку файла2 (для Win это обычно ASCII, для Mac — UTF-8) и выполнить File → Reopen with Encoding….</p>
<p>Environment (Workspace) и History Здесь, в Environment, можно наблюдать переменные и другие объекты, которые создаются в процессе работы кода, а также некоторую информацию о них. Это удобно, поскольку код, бывает, разрастается до сумасшедшего количества строк, и что вы там насоздавали тремястами строками выше — уже и не упомнить. А тут всё под рукой.</p>
<p>В окне History можно найти историю команд, которые вы выполняли. Может быть полезно, чтобы не листать консоль, которая, как правило, завалена результатами и ошибками.</p>
<p>Plots, Files, Packages, Help, Viewer Очень полезное окно в кучей всего.</p>
<p>сюда выводятся графики, которые вы строите здесь можно найти справку по функциям и пакетам проверить, какие у вас установлены пакеты и их версии посмотреть файлы в рабочей директории наблюдать 3D-визуализации, превью отчетов, презентаций и много чего ещё R как калькулятор R — полноценный язык программирования с множеством возможностей, но давайте начнём с малого. Первое, от чего стоит избавиться — это страх консоли. Боязни калькулятора вроде не бывает (но это не точно3), поэтому стартанём с этого.</p>
<p>Арифметические операции В R есть все привычные нам математические операции и операторы для них: +, -, *, /, ^. Выполняются они тоже вполне предсказуемо:</p>
<p>2 + 5 # сложение ## [1] 7 10 - 4 # вычитание ## [1] 6 3 * 7 # умножение ## [1] 21 30 / 3 # деление ## [1] 10 2 ^ 10 # возведение в степень ## [1] 1024 Также есть два особых деления:</p>
<p>5 %/% 2 # целочисленное деление ## [1] 2 5 %% 2 # взятие остатка от деления (5 mod 2) ## [1] 1</p>
<p>Source</p>
<p>В R есть скобки — (). Их назначение такое же, как и в математике. Порядок выполнения арифметических действий (приоритет операторов4, operator precedence) тоже как в математике. Итого имеем:</p>
<p>4 * 4 + 4 ## [1] 20 4 * (4 + 4) ## [1] 32 5 * 5 ^ 5 ## [1] 15625 (5 * 5) ^ 5 ## [1] 9765625 Так что используйте скобки, если вы не уверены, в каком порядке будут выполняться действия. Или смотрите таблицу приоритета операторов по команде ?Syntax.</p>
<p>Функции Но что, если нам надо посчитать что-то более сложное? Например, извлечь корень или вычислить логарифм?</p>
<p>Для вычисления подобных штук существуют функции. К вопросу, что есть функция, мы ещё не раз вернемся, а пока ограничимся самым общим пониманием: функция это некоторая команда, которая имеет вид название_функции(), просит что-то указать у себя в скобках (например, число) и после выполнения возвращает нам некоторый ответ (например, снова число).</p>
<p>На примере с квадратным корнем это выглядит так:</p>
<p>sqrt(4) ## [1] 2 R чувствителен к регистру (case-sensitive), то есть SQRT(4) не сработает.</p>
<p>А вот логарифм:</p>
<p>log(16) ## [1] 2.772589 Вот только здесь есть одна важная деталь. Если мы вспомним определение логарифма, то окажется, что log𝑎𝑏=𝑐⇔𝑎𝑐=𝑏 &gt; Логарифм некоторого числа — это показатель степени, в которую нужно возвести основание, чтобы получить данное число.</p>
<p>Здесь придется чуть углубиться в аргументы функции. Аргументы — это то самое «что-то», что мы записываем в скобках. Бывают обязательные аргументы, без которых функция просто не будет работать и выдаст ошибку, например,</p>
<p>log() # попробуйте выполнить эту команду и необязательные аргументы, у которых уже задано некоторое значение по умолчанию, например, аргумент base у функции log(), который отвечает как раз за задание основания логарифма.</p>
<p>Список аргументов функции можно посмотреть в справке по данной функции, открыв окно Help и введя в поиск название функции, или выполнив одну из следующих команд:</p>
<p>help(log) # ищет справку по функции ?log # синоним предыдущей команды Также в справке можно найти много другой полезной информации.</p>
<p>Согласно хелпу, значение по умолчанию равно 𝑒 , то есть вычисляется натуральный логарифм, если основание не указано. Но подождите, в хелпе не написано никакого 𝑒 , там есть что-то странное в виде exp(1). Да, тут спорить бессмысленно, однако exp(1) — это не что иное, как экспонента от единицы, то есть 𝑒1=𝑒 , что равно:</p>
<p>exp(1) ## [1] 2.718282 Итак, мы выучили две важные вещи: (1) функцию exp() и то, что (2) в качестве аргументов функции можно передавать результаты другой функции. Посмотрите примеры:</p>
<p>log(x = 16, base = 2) # эксплицитно задаём основание и число ## [1] 4 log(x = 16, b = 2) # имена аргументов можно не дописывать, если они не совпадают с другими ## [1] 4 log(base = 2, x = 16) # при таком способе задания порядок аргументов можно менять ## [1] 4 log(625, 25) # имя аргумента можно не писать, но тогда соблюдать порядок следования ## [1] 2 log(16, base = exp(sqrt(2))) # задаём аргумент через результат функций ## [1] 1.960516 log10(1000) # десятичный логарифм ## [1] 3 log2(512) # двоичный логарифм ## [1] 9 На логарифмах, естественно, свет клином не сошёлся, есть и множество других функций, например, тригонометрические (sin(), cos(), …). Да и сами арифметические операции, на самом деле, это тоже функции:</p>
<p>‘+’(7, 3) ## [1] 10 К функциям, как я говорил, мы ещё вернемся, а пока двинемся дальше.</p>
<p>Но перед этим ещё одна важная деталь. Вы, наверняка, заметили, что после команд я часто пишу # и далее текст. Это комментарии. Они крайне важны в коде, поэтому я, и не только я, настоятельно советую вам их оставлять — и чем больше, тем лучше. Сейчас это может казаться бессмысленным, но поверьте, когда ваш код будет занимать 50+ строк — а это очень небольшой код — разобраться уже будет непросто, не говоря о том, что делать, если вы открыли его через месяц или, не дай боже, год…</p>
<p>Source</p>
<p>Закомментить несколько строк сразу можно сочетанием Ctrl + Shift + C (Cmd + Shift + C).</p>
<p>Сравнение и логические операции Как мы знаем, числа можно сравнивать. Также мы знаем, что существуют операторы сравнения — все они есть и в R: &gt;, &lt;, &gt;=, &lt;=, ==, != — больше, меньше, больше или равно, меньше или равно, равно (ли), не равно.</p>
<p>Обратите внимание, что сравнение на равенство осуществляется с помощью оператора ==! Одинарное «равно» (=) имеет другой смысл (см. ниже).</p>
<p>Посмотрим на ряд простых примеров:</p>
<p>2 &gt; 4 ## [1] FALSE 2 &lt; 6 ## [1] TRUE 3 == 5 - 2 ## [1] TRUE 7 &gt;= 7 ## [1] TRUE 4 != 8 ^ 2 ## [1] TRUE Вроде все логично и понятно. Единственное, что стоит помнить, это то, что приоритет операторов сравнения ниже, чем у арифметических операций.</p>
<p>Само по себе сравнение интуитивно понятно, однако нам интересен здесь получаемый результат. Ранее мы имели дело с числами — здесь что-то другое. С одно стороны, программы выдает на слово, но это не простое слово. Это особый тип данных — логическое значение («истина» TRUE или «ложь» FALSE). Типы данных мы обсудим далее, пока же снова ограничимся простым и интуитивным пониманием.</p>
<p>Мы можем составлять из простых сравнений сложные высказывания с помощью логических операторов. Самые известные и часто используемые из них — «И» (&amp;) и «ИЛИ» (|). Подробно об их смысле здесь. Если в двух словах, то «И» истинно, когда оба соединяемых им утверждений истинны, а «ИЛИ» истинно, когда хотя бы одно из соединяемых им утвердений истинно. Например,</p>
<p>2 &gt; 6 &amp; 8 &lt; 12 ## [1] FALSE 1 != 4 &amp; 5 == 10 / 2 ## [1] TRUE 6 + 2 &lt; 10 | 8 == 10 # что по сути эквивалентно 8 &lt;= 10 ## [1] TRUE 1 + 1 == 2 | FALSE &amp; 4 != 2 * 2 ## [1] TRUE (1 + 1 == 2 | FALSE) &amp; 4 != 2 * 2 ## [1] FALSE Как видно из примеров, приоритет логических операторов ниже приоритета операторов сравнения, а приоритет у &amp; выше, чем у |.</p>
<p>Assignment и переменные Мы что-то считаем в R и нам важно не терять результаты вычислений. Для этого существуют переменные, в которые можно записывать промежуточные результаты. Делается это так:</p>
<p>x &lt;- 3 В данном случае мы записали в переменную x значение 3 . Разберёмся подробно:</p>
<p>Обозначаем название переменной, в данном случае x. На самом деле, название может быть любое, однако рекомендуется давать им осмысленные имена, чтобы потом не запутаться. Длинные названия — это, скорее, хорошо. Это немного съедает времени сейчас, но значительно экономит его в будущем! Также НЕ рекомендуется использовать для обозначения переменных названия функций (например, data(), str() и др). Говорим, что надо записать в переменную значение или же присвоить какой-то результат функции. Делается это с помощью оператора присваивания (assignment) &lt;-, который вводится с клавиатуры шорткатом Alt + - (Option + -). Этот оператор записывает то, что справа в то, что слева. Пишем то, что нужно присвоить в переменную. Это может быть конкретное значение, но чаще это результат какой-либо функции, например: y &lt;- sin(90) После создания переменной, она появляется в Environment. Далее переменные можно использовать в вычислениях:</p>
<p>x + y ## [1] 3.893997 x^y * x^2 ## [1] 24.03186 log(y, x) ## [1] -0.1019953 x == y ## [1] FALSE Обратите внимание ещё раз, что сравнивания переменные мы используем оператор ==. А что будет если использовать одно «равно»?</p>
<p>x = y x ## [1] 0.8939967 Выполнилась операция присваивания. Да, её можно записывать и через «равно», но это не очень принято. Традиционно &lt;- используют для присваивания, а = для задания аргументов функций. У оператора присваивания самый низкий приоритет из всех, то есть присваивание выполняется после всех вычислений. Хм, как неожиданно и логично.</p>
<p>Рабочая директория. Projects В ходе нализа данных мы работаем со множеством файлов: скрипты, файлы сырых данных данных, файлы предобработанны данных, файл объектов из рабочего пространства, графики, результаты анализа… Это всё куда-то надо сохранять — вопрос куда?</p>
<p>В R есть понятие рабочей директории. Директория — это синоним папки. Рабочая директория — это папка, в которую смотрит R во время работы. Что это за папка можно узнать через команду:</p>
<p>getwd() # get working directory ## [1] “/Users/antonangelgardt/Downloads/Telegram Desktop/hse_rs_appandan_2023” У меня он смотрел вот в эту папку, у вас, скорее всего, будет что-то типа C://users/имя_пользователя или /Users/имя_пользователя, что указывает на папку пользователя по умолчанию.</p>
<p>Можно установить другую рабочую директорию с помощью команды setwd():</p>
<p>setwd(“/Users/antonangelgardt/R”) # set working directory Теперь он будет смотреть в папку R, которая лежит в дефолтной папке пользователя. Такой способ достаточно удобен, однако можно сделать ещё лучше — создать проект (Project).</p>
<p>Projects Кто-то любит работать в проектах, кто-то нет — дело вкуса. Мне это нравится, даже если вам не понравится. Простите, если мы вдруг не сойдёмся во вкусах, но, повторюсь, это нравится мне, сугубо, лично… Поэтому я буду про это рассказывать и рекламировать.</p>
<p>Зайдите в File → New Project…. У вас откроется такое окно:</p>
<p>Выберите New Directory, затем еще раз New Project:</p>
<p>Откроется вот это:</p>
<p>В Directory name указываем название нашей папки, во втором поле указываем путь к той папке, в которой будет лежать создаваемая папка. Нажимаем Create Project, после чего R перезапускает сессию, и открывается привычное окно. Однако в верхнем правом углу R теперь указано название проекта, в котором мы работаем.</p>
<p>Много ли это приносит профита? Ну, не так уж и много… По сути, что открыть проект, что выполнить setwd(“пусть_к_папке”) — примерно одно и то же. Вот только строку кода можно забыть запустить после открытия скрипта, а если мы запустили проект, мы уверены, что у нас все автоматически настроилось и ошибок не будет.</p>
<p>Типы данных Итак, до какого-то момента мы работали только с числами, а затем начали их сравнивать, и получили что-то новое типа TRUE и FALSE. И как мы отметили, это новый тип данных.</p>
<p>А что такое вообще тип данных? Тип данных — это характеристика данных, которая определяет:</p>
<p>множество допустимых значений, которые могут принимать данные этого типа, и набор операций, которые можно осуществлять с данными этого типа. Что это значит, будем разбираться на конкретных примерах.</p>
<p>numeric Этот тип данных нам уже знаком — это числа. Например, если мы создадим переменную со значением 7 и захотим узнать её тип, то это будет выглядеть так:</p>
<p>a &lt;- 7 class(a) # эта команда выводит тип данных ## [1] “numeric” Итак, действительно, 7 — это число, нас не обманули.</p>
<p>Вообще-то, в R много типов числовых данных: integer (целые числа), double (числа с десятичной дробной частью), complex (комплексные числа). Последние вам вряд ли встретятся в ближайшее время, а по поводу деления первых можно особо не заморачиваться — R сам разберется, что к чему, и переконвертирует как надо.</p>
<p>Однако для интересующихся есть спойлер — все дело в том, как храняться числа] на железе. А о комплексных числах в R немного можно почитать тут.</p>
<p>Если мы всё же хотим выяснить, что это за числовые данные, то воспользуется функцией typeof():</p>
<p>typeof(a) ## [1] “double” На числовых данных выполняются все математические операции и различные функции, с чем мы развлекались на протяжении предыдущей главы. А множество значений этого типа, как вы понимаете, бесконечно.</p>
<p>logical Здесь все гораздо проще. Есть всего два значение TRUE и FALSE, то есть «истина» и «ложь». Получаются логические данные в результате сравнения — и мы это уже тоже видели в предыдущей главе — и на себе сравнение они также допускают.</p>
<p>TRUE == TRUE # но вообще-то это операция, которая не несет никакого смысла ## [1] TRUE FALSE != FALSE # эта тоже не несет ## [1] FALSE FALSE == TRUE # и эта ## [1] FALSE TRUE и FALSE — это логические константы, и, обратите внимание, записываются они прописными буквами. true и True не сработают. Правда есть вариант записывать их только одной буквой T и F, но c’est mauvais ton, и вот почему:</p>
<p>T == TRUE ## [1] TRUE T &lt;- FALSE T == TRUE ## [1] FALSE Константы TRUE и FALSE защищены от перезаписи (на то они и константы).</p>
<p>Поэтому мы не будем жалеть времени и символы и в угоду удобочитаемости и стабильности кода будем писать логические константы полностью.</p>
<p>Кроме сравнения, логический тип данных допускается на себе логические операции, что в общем-то логично.</p>
<p>Основных операций две:</p>
<p>логическое И (конъюнкция, &amp;, ∧ , ⋅ ) логическое ИЛИ (дизъюнкция, |, ∨ , + ) Работают они следующим образом в соответствии с таблицей истинности:</p>
<p>TRUE &amp; TRUE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE FALSE &amp; TRUE ## [1] FALSE FALSE &amp; FALSE ## [1] FALSE TRUE | TRUE ## [1] TRUE TRUE | FALSE ## [1] TRUE FALSE | TRUE ## [1] TRUE FALSE | FALSE ## [1] FALSE Можем создать и более сложные конструкции. Например, с участие переменных:</p>
<p>x &lt;- 2 y &lt;- 6 n &lt;- 7</p>
<p>x &gt; 2 &amp; y &lt; 10 ## [1] FALSE x != 100 | n != 7 ## [1] TRUE !(x != 100 | n != 7) ## [1] FALSE Заметьте, что ! существует не только в составе !=, но и как самостоятельный логический оператор и обозначает логическое отрицание.</p>
<p>Также есть оператор xor() (который выглядит как функция5), обозначающий исключающее ИЛИ. Это логическая функция от двух переменных и работает вот так:</p>
<p>xor(TRUE, TRUE) ## [1] FALSE xor(TRUE, FALSE) ## [1] TRUE xor(FALSE, TRUE) ## [1] TRUE xor(FALSE, FALSE) ## [1] FALSE Он используется редко, но может когда-нибудь внезапно пригодиться.</p>
<p>character Очевидно, что в практике мы не всегда имеет дело только с цифрами, мы храним ещё и текстовую информацию. Для этого есть тип данных character (хотя другие языки программирования с R бы поспорили).</p>
<p>x &lt;- “Доброе утро, девочки!” class(x) ## [1] “character” character — это строки (strings) символов, поэтому они должны быть закавычены одинарными (’) или двойными (“) кавычками. Так R поймёт, где строка начинается и где заканчивается. Большой разницы между одинарными и двойными кавычками нет, но если у вас кавычки внутри кавычек, здесь надо быть аккуратным:</p>
<p>x &lt;- ‘Мужчина громко зашёл в комнату и высказал решительное “здравствуйте”’ x ## [1] “Мужчина громко зашёл в комнату и высказал решительное "здравствуйте"” А вообще, есть беспроигрышный [и типографически верный] вариант:</p>
<p>x &lt;- ‘Мужчина громко зашёл в комнату и высказал решительное «здравствуйте»’ x ## [1] “Мужчина громко зашёл в комнату и высказал решительное «здравствуйте»” Строковый тип данных мы еще подробно обсудим в теме работы со строками, а пока посмотрим вот на что…</p>
<p>Конечно, чтобы разговор и типах данных был полным, необходимо сказать о таком типе данных как factor. Хотя он не является «базовым» типом, Всё же ему необходимо уделить некоторое внимание.</p>
<p>factor Фактор — это строковые данные, которые хранятся как числа. Почему там делать удобно? Потому что фактор содержит определённый (как правило, небольшой) набор уникальных значений (чаще всего около 2–5).</p>
<p>Для чего используются факторы? Для задания каких-либо групп в данных. Например, у вас есть экспериментальные данные, в которых есть два экспериментальных условия и одно контрольное. Тогда вектор, задающий эти условия может выглядет примерно так:</p>
<p>conditions &lt;- c(‘exp1’, ‘exp2’, ‘control’, ‘exp1’, ‘exp1’, ‘exp2’, ‘control’, ‘exp2’, ‘control’) conditions ## [1] “exp1” “exp2” “control” “exp1” “exp1” “exp2” “control” ## [8] “exp2” “control” Сейчас это строковый вектор — это достаточно просто превратить в фактор:</p>
<p>as.factor(conditions) ## [1] exp1 exp2 control exp1 exp1 exp2 control exp2 control ## Levels: control exp1 exp2 В аутпуте добавилась строчка Levels, которая как раз и определяет набор уникальных значений. По умолчанию уровни фактора выстраиваются в алфавитном (лексикографическом) порядке. Если вам принципиален порядок факторов — например, в случае эксперимента на зрительный поиск у вас есть несколько visual set size (количество стимулов в пробе) — тогда можно воспользоваться специальной функцией и создать упорядоченный фактор:</p>
<p>vis_set_size &lt;- factor(rep(c(3, 6, 9), times = 10), levels = c(3, 6, 9), # задаём порядок уровней ordered = TRUE) # указываем, что нам нужн упорядоченный вектор vis_set_size ## [1] 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 ## Levels: 3 &lt; 6 &lt; 9 Теперь в строке Levels указаны не только сами уровни, но и отношение порядка для множестве значений. Как видите, в фактор можно превратить не только текстовый вектор, но и числовой.</p>
<p>В актуальных версиях R обычно текстовые векторы автоматически приводятся к факторам в тех случаях, когда это нужно. Однако если нам нужен числовой вектор как факторный, это придется делать вручную. Хотя, конечно, числовые данные мы чаще всего рассмтариваем именно как числовые.</p>
<p>Coercion [part one] А что будет, если мы пренебрежём допустимыми операциями и попробуем, например, сложить не-числа? Допустим, так:</p>
<p>TRUE + TRUE # складываем две истины ## [1] 2 Внезапно, команда выполнилась. Можно задаться вопросом, почему именно так, ведь правила алгебры логики говорят, что должно быть по-другому. Опуская детали, скажем, что оператор + несет только арифметический, но не логический смысл, поэтому произошло следующее:</p>
<p>оператор + умеет работать только с числовыми значениями но получил логические поэтому попробовал привести их к числовым у него получилось — TRUE легко и непринуждено приводится к 1, а FALSE к 0 далее выполнилось сложение Такое поведение называется приведение типов (coercion). Подробно мы его будем обсуждать позже, когда изучим структуры данных и поймем, какие опасности это может за собой влечь. Сейчас же ознакомимся с некоторыми примерами.</p>
<p>Приведение типов сработает не всегда. Например, если мы попытаемся сложить строки6, то получим ошибку:</p>
<p>“abc” + “cbd” ## Error in “abc” + “cbd”: non-numeric argument to binary operator Чтобы контролировать приведение типов, есть семейство функций as.*(). Посмотрим, как они работают.</p>
<section id="приводим-логические-данные-в-числовым" class="level1" data-number="21">
<h1 data-number="21"><span class="header-section-number">21</span> приводим логические данные в числовым</h1>
<p>as.numeric(TRUE) ## [1] 1 as.numeric(FALSE) ## [1] 0 # приводим числовые данные к логическим as.logical(1) ## [1] TRUE as.logical(0) ## [1] FALSE as.logical(-1) ## наблюдаем, что все не так однозначно ## [1] TRUE as.logical(0.4) ## [1] TRUE as.logical(sqrt(2)) ## [1] TRUE # числовые данные к строке as.character(23) ## [1] “23” as.character(-150) ## [1] “-150” # логические данные к строке as.character(TRUE) ## [1] “TRUE” as.character(FALSE) ## [1] “FALSE” Поздравляю! Мы закончили с основами основ! Пора переходить к самому важному и интересному — структурам данных, а именно – векторам!</p>
<p>Структуры данных С тем, какие существуют данные, мы разобрались. Теперь надо понять, как мы их можем организовать.</p>
<p>Векторы Простейший способ организации данных — это вектор. Казалось бы, мы знаем, что вектор — это направленный отрезок. Безусловно, это так — в рамках Евклидовой геометрии, которую мы в давнем прошлом учили. Однако это не единственный способ смотреть на вещи. С точки зрения структур данных, вектор — это одномерный массив, а если по-русски, то набор элементов одного типа (например, чисел).</p>
<p>Эти два представления, на самом деле, не противоречат друг другу. Геометрически, как мы сказали, вектор — это направленный отрезок. Он задаётся через координаты начала и конца. Если мы условимся всегда начинать вектор из начала координат — то есть будет считать равными все векторы, которые имеют одинаковую длину и одинаковое направление7 — то мы сможем задавать вектор только через координаты его конца. В случае двумерного пространства вектор будет однозначно задаваться парой чисел (𝑥,𝑦) , в случае трёхмерного — тройкой чисел (𝑥,𝑦,𝑧) , а в случае 𝑛 -мерного пространства — набором чисел (𝑥1,𝑥2,𝑥3,…,𝑥𝑛) .</p>
<p>Чтобы создать вектор в R надо воспользоваться функцией c(). Она принимает неограниченное количесво аргументов, которые объединяет в вектор. В вектор можно объединить элементы только одного типа.</p>
<p>v &lt;- c(1,2,3,5,6,7) Сохраним получившийся числовой вектор в переменную v. Присваивание векторов ничем не отличается от присваивания чисел, во-первых, потому что в R нет скаляров, и все числа — это векторы типа numeric длиной 1, а во-вторых, потому что и число, и вектор, и другие структуры данных (и даже функции!) — всё это объекты. А assignment — не что иное, как присваивание имени некоторому объекту, и нет разницы, что мы называем — число, матрицу, список, датафрейм или функцию.</p>
<p>Coercion [part two] Взбунтуемся, и объеденим в один вектор разные типы данных:</p>
<p>v0 &lt;- c(1, 2, TRUE, FALSE) v0 ## [1] 1 2 1 0 Бунт не удался — вектор всё равно был создан. Но что произошло?</p>
<p>С приведением типов мы уже сталкивались, когда пытались складывать логические константы. Аналогично R действовал и здесь:</p>
<p>есть задача создать вектор но на выход функции поступили данные различных типов придётся сделать так, чтобы тип был всё-таки один numeric к logical однозначно привести сложно (что есть 2 — TRUE или FALSE?) logical к numeric приводится очень хорошо и красиво (TRUE — 1, FALSE — 0) после приведения типов можно выполнить команду создания вектора. Сделаем вектор из полного салата — добавим сторовые значения:</p>
<p>v0 &lt;- c(1, 2, TRUE, FALSE, ‘text’, ‘string’) v0 ## [1] “1” “2” “TRUE” “FALSE” “text” “string” Наблюдаем, что все свелось к типу character, что вполне ожидаемо, так как 2 в “2” превращается однозначно, а вот в какое число (или логическую константу) превратить “string”, не очень понятно.</p>
<p>Собственно, можно вывести иерархию приведения типов:</p>
<p>logical &lt; integer &lt; numeric &lt; complex &lt; character Генерация числовых последовательностей Создавать руками векторы — это, конечно, радостно и приятно, но не очень юзабельно. На практике часто возникает потребность сгенерировать определенную числовую последовательность. Например, у вас есть опросниковые данные, из которых необходимо удалить персональные данные, но при этом сохранить возможность соотнести персональные данные и результаты анализа по каждому респонденту — вам нужно сгенерировать переменную ID. Вам поможет оператор :, который генерирует последовательность в заданных пределах с шагом 1:</p>
<p>1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 15:0 ## [1] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 Если вам нужна последовательно с другим шагом, например, 0.5, то подойдет функция seq():</p>
<p>seq(from = 1, to = 10, by = 0.5) # задаём шаг последовательности ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 ## [16] 8.5 9.0 9.5 10.0 seq(0, -6, -1.5) # или без указания названий аргументов ## [1] 0.0 -1.5 -3.0 -4.5 -6.0 seq(from = 5, to = 30, length.out = 20) # задаём длину последовательности ## [1] 5.000000 6.315789 7.631579 8.947368 10.263158 11.578947 12.894737 ## [8] 14.210526 15.526316 16.842105 18.157895 19.473684 20.789474 22.105263 ## [15] 23.421053 24.736842 26.052632 27.368421 28.684211 30.000000 Допустим, у вас есть данные (пусть выборка будет 15 человек), в которых каждые две строки относятся к одному респонденту, но к двум различным экспериментальным условиям (экспериментальному и контрольному). Тогда можно сделать такие переменные:</p>
<p>rep(1:15, each = 2) # для id ## [1] 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 ## [26] 13 14 14 15 15 rep(c(‘exp’, ‘control’), times = 15) # для обозначения условия ## [1] “exp” “control” “exp” “control” “exp” “control” “exp”<br>
## [8] “control” “exp” “control” “exp” “control” “exp” “control” ## [15] “exp” “control” “exp” “control” “exp” “control” “exp”<br>
## [22] “control” “exp” “control” “exp” “control” “exp” “control” ## [29] “exp” “control” Также можно сгенерировать случайную последовательность чисел (например, для того, чтобы использовать её при сабсете случайной подвыборки данных):</p>
<p>sample(x = 1:30, size = 15) ## [1] 4 13 20 16 25 24 10 1 8 23 17 2 15 5 12 Чтобы результат генерации при повторном запуске кода получался одним и тем же, перед выполнением команды sample(…) нужно выполнить команду set.seed(…):</p>
<p>set.seed(69) Число внутри функции может быть абсолютно любым.</p>
<p>Операции с векторами Операции, которые можно выполнять над векторами зависят от типа данных, которые содержатся в векторе. Чаще всего мы будем работать с числовыми векторами, поэтому разберем подробно именно их.</p>
<p>Пусть у нас будет два вектора:</p>
<p>set.seed(42) # задаём положение для датчика случайных чисел v1 &lt;- sample(1:100, 20) v2 &lt;- sample(-50:100, 20) Над векторами можно выполнять арифметические операции:</p>
<p>v1 + v2 ## [1] 56 56 -2 66 110 200 132 9 88 147 78 -27 74 66 -4 110 115 70 -14 ## [20] 154 v1 - v2 ## [1] 42 74 52 82 -74 0 -38 39 54 31 -4 67 -22 -60 86 -56 -43 -60 82 ## [20] 20 v1 * v2 ## [1] 343 -585 -675 -592 1656 10000 3995 -360 1207 5162 1517 -940 ## [13] 1248 189 -1845 2241 2844 325 -1632 5829 v1 / v2 ## [1] 7.00000000 -7.22222222 -0.92592593 -9.25000000 0.19565217 1.00000000 ## [7] 0.55294118 -1.60000000 4.17647059 1.53448276 0.90243902 -0.42553191 ## [13] 0.54166667 0.04761905 -0.91111111 0.32530120 0.45569620 0.07692308 ## [19] -0.70833333 1.29850746 Они выполняются поэлементно, то есть соответсвующие элементы двух векторов складываются (вычитаются, умножаются, делятся), и в результате получается новый вектор.</p>
<p>Кроме того, векторы можно поэлементно сравнивать:</p>
<p>v1 &lt; v2 ## [1] FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE ## [13] TRUE TRUE FALSE TRUE TRUE TRUE FALSE FALSE v1 == v2 ## [1] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE v2 &lt;= v1 ## [1] TRUE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE TRUE ## [13] FALSE FALSE TRUE FALSE FALSE FALSE TRUE TRUE Также к вектору можно применять и функции:</p>
<p>sin(v1) ## [1] -0.9537527 0.8268287 -0.1323518 -0.9851463 -0.7509872 -0.5063656 ## [7] 0.1235731 -0.9055784 0.9510547 0.8600694 -0.6435381 0.9129453 ## [13] 0.7625585 0.1411200 -0.1586227 0.9563759 -0.9917789 -0.9589243 ## [19] 0.5290827 -0.8218178 log(v1) ## [1] 3.891820 4.174387 3.218876 4.304065 2.890372 4.605170 3.850148 3.178054 ## [9] 4.262680 4.488636 3.610918 2.995732 3.258097 1.098612 3.713572 3.295837 ## [17] 3.583519 1.609438 3.526361 4.465908 exp(v2) ## [1] 1.096633e+03 1.234098e-04 1.879529e-12 3.354626e-04 9.017628e+39 ## [6] 2.688117e+43 8.223013e+36 3.059023e-07 2.415495e+07 1.545539e+25 ## [11] 6.398435e+17 3.873998e-21 7.016736e+20 2.293783e+27 2.862519e-20 ## [16] 1.112864e+36 2.038281e+34 1.694889e+28 1.425164e-21 1.252363e+29 Можно применять несколько функций подряд:</p>
<p>log(abs(v2)) ## [1] 1.945910 2.197225 3.295837 2.079442 4.521789 4.605170 4.442651 2.708050 ## [9] 2.833213 4.060443 3.713572 3.850148 3.871201 4.143135 3.806662 4.418841 ## [17] 4.369448 4.174387 3.871201 4.204693 Большинство арифметических функций выполняется поэлементно, однако существуют такие, которые поэлементно не могут быть выполнены, например сумма по вектору:</p>
<p>sum(v1) ## [1] 878 Или функция, которая вычисляет длину вектора (в смысле количества элементов в нём):</p>
<p>length(v2) ## [1] 20 Recycling Доныне мы складывали векторы одинаковой длины. С ними всё ясно — они складываются поэлементно. А что будет, если мы сложим векторы разной длины?</p>
<p>v3 &lt;- rep(1, times = 10); v3 # создаём векторы ## [1] 1 1 1 1 1 1 1 1 1 1 v4 &lt;- sample(1:100, 2); v4 ## [1] 21 2 v5 &lt;- sample(1:100, 3); v5 ## [1] 58 10 40 length(v3) # проверяем длину ## [1] 10 length(v4) ## [1] 2 length(v5) ## [1] 3 Итак, сумма:</p>
<p>v3 + v4 ## [1] 22 3 22 3 22 3 22 3 22 3 v3 + v5 ## Warning in v3 + v5: longer object length is not a multiple of shorter object ## length ## [1] 59 11 41 59 11 41 59 11 41 59 Внимательно посмотрим на результат. В первом случае мы складывали вектор из десяти элементов и вектор из двух элементов. Чтобы выполнирь эту операцию R выполняет зацикливание (recycling) более короткого из двух, чтобы каждый элемент большего по длине вектора получил в соответствии элементн меньшего. Так как десять кратно двум, то по сути было выполнена следующая команда:</p>
<p>v3 + rep(v4, times = length(v3) / length(v4)) ## [1] 22 3 22 3 22 3 22 3 22 3 Во втором случае длина меньшего вектора не кратна длине большего, поэтому recycling происходит до тех пор, пока не будут покрыты все элемент большего вектора. Вектор из трех элементов укладывается на вектор из десяти элементов три раза — поэтому мы видим в результате три раза последовательность 59, 11, 41 — и остается ещё один десятый элемент, который суммируется в первым элементом меньшего вектора — поэтому последний элемент в векторе результата 59.</p>
<p>Индексация векторов В практике мы постоянно сталкиваемся в необходимость анализировать не все данные в векторе, а их часть. Поэтому встаёт вопрос о том, как эту часть извлечь?</p>
<p>Извлечение части данных из вектора называется индексацией. Это делается так:</p>
<p>v1[1:10] # первые десять элементов вектора ## [1] 49 65 25 74 18 100 47 24 71 89 v1[c(1,3,5,7)] # 1-й, 3-й, 5-й и 7-й элементы вектора ## [1] 49 25 18 47 v1[sample(1:20, 5)] # случайная подвыборка пяти элементов ## [1] 18 49 36 47 74 Логика проста — чтобы взять часть вектора, нам нужен вектор индексов тех элементов, которые мы хотим вытащить. Его мы поместим в квадратные скобки — и будет нам счастье. Вектор индектов можно получить любыми способами:</p>
<p>сгенерировать последовательноть (как в первом варианте), задать индексы вручную, не забыв при этом обернуть их в фнукцию c(), чтобы указать, что это вектор, (как во втором варианте), воспользоваться функцией, которая возвращает вектор. Полезно также является индексация через отрицательные индексы:</p>
<p>v2 ## [1] 7 -9 -27 -8 92 100 85 -15 17 58 41 -47 48 63 -45 83 79 65 -48 ## [20] 67 v2[-1] # все элементы, кроме первого ## [1] -9 -27 -8 92 100 85 -15 17 58 41 -47 48 63 -45 83 79 65 -48 67 v2[-(1:5)] # все элементы, кроме первых пяти ## [1] 100 85 -15 17 58 41 -47 48 63 -45 83 79 65 -48 67 Особого внимания заслуживает индексация логическими векторами. Например, мы хотим отобрать все элементы вектора, которые больше некоторого числа. Как это сделать?</p>
<p>Нам нужен вектор, которым мы будем индексировать исходный вектор. Как его получить? Известно, что при сравнении векторов между собой получается логический вектор. Но ведь число — это тоже вектор, просто единичной длины? Значит, если мы будем сравнивать вектор с числом, произойдёт recycling, в результате которого каждый элемент вектора будет сравнен с этим числом. То есть:</p>
<p>v1 &gt; 40 ## [1] TRUE TRUE FALSE TRUE FALSE TRUE TRUE FALSE TRUE TRUE FALSE FALSE ## [13] FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE Отлично! Вектор есть. Можно ли им проидексировать наш исходный вектор v1? Можно! Аналогично тому, как мы это уже делали.</p>
<p>v1[v1 &gt; 40] ## [1] 49 65 74 100 47 71 89 41 87 Конструкция, возможно, выглядит немного странновато — но работает!</p>
<p>NA, NaN, NULL Взбунтуемся ещё раз и посмотрим, что получится, если мы будем вытаскивать из вектора элементы, используя индексы, которые выходят за границы длины вектора. Например, у нас есть вектор v2, длина которого</p>
<p>length(v2) ## [1] 20 Попробуем сделать так:</p>
<p>v2[15:25] ## [1] -45 83 79 65 -48 67 NA NA NA NA NA Мы получили нечто, с чем ранее не сталкивались. NA (от not available) обозначает значение, которое недоступно. Как правило, в реальных данных они появляются при каких-либо ошибках записи данных. Впрочем, не всегда. Можно придумать и такой дизайн исследования, когда пропуски также будут информативны и могут анализировться. В нашем случае мы обратились к элементам, которых нет в нашем векторе, поэтому R ничего более не смог сделать, как вернуть нам свидетельство того, что такие элементы он из вектора достать не смог.</p>
<p>NA ведёт себя весьма специфично. Например, если мы попробуем посчитать сумму по получившемуся вектору, то результат будет следующим:</p>
<p>sum(v2[15:25]) ## [1] NA Аналогичная ситуация возникнет, если мы будем вычислять среднее:</p>
<p>mean(v2[15:25]) ## [1] NA Такое поведение функций может поначалу напрягать, однако оказывается очень полезным при работе с реальными данными.</p>
<p>И всё же функция sum() не так проста, и умеет бороться с NA. Для этого у неё есть аргумент na.rm, которому нужно задать значение TRUE, если мы хотим, чтобы сумма все же была посчитана:</p>
<p>sum(v2[15:25], na.rm = TRUE) ## [1] 201 Попробуем вычислить логарифм по вектору v2:</p>
<p>log(v2) ## Warning in log(v2): NaNs produced ## [1] 1.945910 NaN NaN NaN 4.521789 4.605170 4.442651 NaN ## [9] 2.833213 4.060443 3.713572 NaN 3.871201 4.143135 NaN 4.418841 ## [17] 4.369448 4.174387 NaN 4.204693 Опять всё не слава богу. Теперь у нас NaN. Это почти как NA, но не совсем. NaN обозначает не-число (not a number). То есть, это не пропущенное значение, оно существует, но R его не может вычислить. Если мы сравним два вектора,</p>
<p>v2; log(v2) ## [1] 7 -9 -27 -8 92 100 85 -15 17 58 41 -47 48 63 -45 83 79 65 -48 ## [20] 67 ## Warning in log(v2): NaNs produced ## [1] 1.945910 NaN NaN NaN 4.521789 4.605170 4.442651 NaN ## [9] 2.833213 4.060443 3.713572 NaN 3.871201 4.143135 NaN 4.418841 ## [17] 4.369448 4.174387 NaN 4.204693 то обнаружим, что NaN появляется там, где мы пытаемся вычислить логарим отрицательного числа. А, как мы помним, функция логарифма определена только на положительно полуоси 𝑥 . Вот и получается, что логарифм отрицательного аргумента — это какая-то неведомая сущность, то точно не-число.</p>
<p>В функциях NaN ведёт себя аналогично NA:</p>
<p>sum(log(v2)) ## Warning in log(v2): NaNs produced ## [1] NaN Мы поговорили о двух важный константах используемых в R. Есть ещё одна, и имя её NULL. Это имя обозначает «ничего», то есть, что объект пуст.</p>
<p>Например, возьмем вектор v, который мы создавали в самом начале, и положим в него NULL:</p>
<p>v &lt;- NULL v ## NULL Теперь в этом векторе ничего не лежит.</p>
<p>NULL может использоваться при задании аргументов функций или как результат работы функций, если возвращается пустой объект.</p>
<p>Матрицы Говоря о векторах, мы обозначили, что вектор — это одномерный массив. А раз есть одномерные массивы, значит бывают какие-то ещё? Да. Сгенерируем некоторый вектор:</p>
<p>v6 &lt;- sample(1:100, 12); v6 ## [1] 73 29 76 84 9 35 93 16 92 69 2 82 и попробуем его «сложить» в «таблицу» так, чтобы в каждой строке было по три числа:</p>
<p>m1 &lt;- matrix(v6, ncol = 3); m1 ## [,1] [,2] [,3] ## [1,] 73 9 92 ## [2,] 29 35 69 ## [3,] 76 93 2 ## [4,] 84 16 82 Так как мы «складываем друг на друга» части одномерного массива, у нашего нового массива возникает новое измерение — если вектор был только одной строкой, то теперь в нашем массиве есть и строки, и столбцы. Двумерный массив назвается матрицей.</p>
<p>class(m1) ## [1] “matrix” “array” И поэтому для его создания мы использовали функцию matrix(). В качестве основных аргументов она хочет видеть вектор, который мы будет «упаковывать» в матрицу, а также количество строк или столбцов новой матрицы.</p>
<p>Индексация матриц От того, что мы свернули вектор в матрицу, он не перестал быть вектором. [Шок!] То есть матрица по сути всё ещё тот же самый вектор, поэтому индексировать её можно точно так же, как и вектор:</p>
<p>v6[1]; m1[1] ## [1] 73 ## [1] 73 v6[4]; m1[4] ## [1] 84 ## [1] 84 v6[11]; m1[11] ## [1] 2 ## [1] 2 Однако поскольку матрица — это всё же матрица, она отличается от вектора тем, что у неё есть дополнительный атрибут dim, который отображает её размерность:</p>
<p>dim(m1) ## [1] 4 3 В данном случае наблюдаем, что размерность матрицы 4×3 , и это справедливо, ведь именно такую матрицу мы и создавали. А раз у нас имеется указание на количество строк и столбцов в матрице, то мы можем вытащить элемент(ы) как раз по его позиции:</p>
<p>m1[1, 2] # вытаскиваем элемент из первой строки и второго столбца ## [1] 9 Те же квадратные скобки, только указываем мы теперь две «координаты» — сначала строки, затем столбцы. Как не запутаться? Аналогия с координатами не случайна: строки — горизонтальны, первая координата на координата на координатной плоскости (𝑥 ) тоже задаёт положение точки на горизонтальной оси; столбцы — вертикальны, вторая координата (𝑦 ) задает положение точки на вертикальной оси.</p>
<p>Также мы можем вытащить не только отдельный элемент, но и какую-то часть матрицы. Всё работает аналогично векторам:</p>
<p>m1[1:3, 2:3] ## [,1] [,2] ## [1,] 9 92 ## [2,] 35 69 ## [3,] 93 2 Если мы выползем за границы индексации, R начнёт ругаться:</p>
<p>m1[1:3, 2:4] ## Error in m1[1:3, 2:4]: subscript out of bounds Операции c матрицами См. книжку.</p>
<p>Списки До текущего момента мы говорили о структурах данных, которые требуют одинакового типа данных в себе. Давайте теперь вообразим вектор без ограничения на однотипность данных. Это будет список (list).</p>
<p>l &lt;- list(69, “text”, TRUE) l ## [[1]] ## [1] 69 ## ## [[2]] ## [1] “text” ## ## [[3]] ## [1] TRUE Но список даёт нам ещё больше возможностей, потому что он может собирать в себя вообще любые объекты:</p>
<p>l2 &lt;- list(c(“This”, “list”, “contains”, “a”, “matrix”), m1, l) l2 ## [[1]] ## [1] “This” “list” “contains” “a” “matrix”<br>
## ## [[2]] ## [,1] [,2] [,3] ## [1,] 73 9 92 ## [2,] 29 35 69 ## [3,] 76 93 2 ## [4,] 84 16 82 ## ## [[3]] ## [[3]][[1]] ## [1] 69 ## ## [[3]][[2]] ## [1] “text” ## ## [[3]][[3]] ## [1] TRUE Таким образом, список может являть собой крайне сложную структуру. Чтобы разобраться, как устроен конкретный список, можно воспользоваться функцией str(), которая отобразит структуру списка:</p>
<p>str(l2) ## List of 3 ## $ : chr [1:5] “This” “list” “contains” “a” … ## $ : int [1:4, 1:3] 73 29 76 84 9 35 93 16 92 69 … ## $ :List of 3 ## ..$ : num 69 ## ..$ : chr “text” ## ..$ : logi TRUE Как видно в аутпуте функции, список содержит три элемента: текстовый вектор длиной 5, массив целых чисел, размером 4×3, и список, который в свою очерель состоит также из трёх элементов — числа 69, строкового вектора, содержащего одно значение (“text”) и логического вектора длиной 1, который содержит значение «истина».</p>
<p>Можно назвать отдельные элементы списка собственными именами:</p>
</section>
<section id="создадим-список-такой-же-как-l2-только-именованный" class="level1" data-number="22">
<h1 data-number="22"><span class="header-section-number">22</span> создадим список такой же, как l2, только именованный</h1>
<p>l3 &lt;- list(description = c(“This”, “list”, “contains”, “a”, “matrix”), matrix = m1, inner_list = l) l3 ## $description ## [1] “This” “list” “contains” “a” “matrix”<br>
## ## $matrix ## [,1] [,2] [,3] ## [1,] 73 9 92 ## [2,] 29 35 69 ## [3,] 76 93 2 ## [4,] 84 16 82 ## ## $inner_list ## $inner_list[[1]] ## [1] 69 ## ## $inner_list[[2]] ## [1] “text” ## ## $inner_list[[3]] ## [1] TRUE Индексация списков Списки в R появляются достаточно часто — и, главным образом, как результат работы функций. Собственными руками мы их создавать вряд ли когда либо будем, а вот вытаскивать из них инфу по частям нам научиться надо обязательно.</p>
<p>Поскольку список как и вектор состоит из отдельных элементов, которые в нём расположены в определённом порядке, то можно поступить со списком как с вектором:</p>
<p>l3[1] ## $description ## [1] “This” “list” “contains” “a” “matrix” Мы помним, что с списке l3 первым элементом был строковый вектор. Однако когда мы обратились к первому элементу, нам вернулся список, содержащий этот вектор. Да, такова особенность индексации списков — если мы используем одинарные квадратные скобки, то возвращается список из одного элемента. Почему так? Потому что если мы заходим вытащить, например, первые два элемента, то они могут оказаться различной структуры, и вернуть их вместе, кроме как списком, нет варианта.</p>
<p>l3[1:2] ## $description ## [1] “This” “list” “contains” “a” “matrix”<br>
## ## $matrix ## [,1] [,2] [,3] ## [1,] 73 9 92 ## [2,] 29 35 69 ## [3,] 76 93 2 ## [4,] 84 16 82 Чтобы вытащить сам вектор, нам потребуются двойные квадратные скобки:</p>
<p>l3[[1]] ## [1] “This” “list” “contains” “a” “matrix” Можно пойти далее и вытащить какой-то элемент из вектора прямо в этой же строке:</p>
<p>l3[[1]][c(1, 5)] # вытащим сразу первый и пятый ## [1] “This” “matrix” Раз у нас именованный список, то можно вытащить элемент по имени (с векторами тоже работает):</p>
<p>l3[‘matrix’] # так вернётся список ## $matrix ## [,1] [,2] [,3] ## [1,] 73 9 92 ## [2,] 29 35 69 ## [3,] 76 93 2 ## [4,] 84 16 82 l3[[‘matrix’]] # а так сама матрица ## [,1] [,2] [,3] ## [1,] 73 9 92 ## [2,] 29 35 69 ## [3,] 76 93 2 ## [4,] 84 16 82 Но списки нам предоставляют ещё одну удобную и полезную фичу — индексацию по имени, но другим способом:</p>
<p>l3<span class="math inline">\(description
## [1] "This"     "list"     "contains" "a"        "matrix"
l3\)</span>matrix ## [,1] [,2] [,3] ## [1,] 73 9 92 ## [2,] 29 35 69 ## [3,] 76 93 2 ## [4,] 84 16 82 Обратите внимание, что в таком случае сразу возвращается «голый» объект — вектор, матрица, etc. Запомните этот способ — так мы будем делать о-о-очень часто (примерно всегда).</p>
<p>Датафреймы Ура! Мы добрались до самого интересноо в самого важного!</p>
<p>Кратко вспомним, что мы умеем к этому моменту:</p>
<p>манипулировать с векторами (создавать, индексировать, производить разные математические операции) работать с матрицами (создавать, индексировать, производить разные математические операции) обращаться со списками (создавать и индексировать различными способами) Так вот все эти знания и умения нам нужны, чтобы мастерски жонглировать датафреймами. Датафрейм — это детище большой любви матрицы и списка:</p>
<p>В одном из домашних заданий вы создавали матрицу, которая содержала имена респондентов, их пол, город проживания и любимый цвет. Но ождиаемое ограничение было в том, что все данные неизбежно приводились к строковому типу. И в таком варианте вроде бы ничего криминального, но если мы захотим добавить данные о возраста — что делать? Хорошо мы, чтобы они сохранились в числовом формате, ведь так с ними дальше будет удобно работать.</p>
</section>
<section id="немного-изменим-набор-переменных-для-демонстрации-возможностей" class="level1" data-number="23">
<h1 data-number="23"><span class="header-section-number">23</span> немного изменим набор переменных для демонстрации возможностей</h1>
<p>df &lt;- data.frame(name = c(‘Илья’, ‘Алёна’, ‘Виктор’, ‘Елена’, ‘Кристина’), age = c(21, 34, 19, 52, 26), sex = c(‘муж’, ‘жен’, ‘муж’, ‘жен’, ‘жен’), city = c(“Орёл”, “Тверь”, “Тирасполь”, “Питер”, “Москва”)) df ## name age sex city ## 1 Илья 21 муж Орёл ## 2 Алёна 34 жен Тверь ## 3 Виктор 19 муж Тирасполь ## 4 Елена 52 жен Питер ## 5 Кристина 26 жен Москва Обратите внимание, датафрейм создается практически так же, как и список, только функция другая. А в итоге получается привычная нам таблица! Magique!</p>
<p>Как устроена эта таблица? По сути датафрейм — это именованный список, каждый элемент которого — это вектор определённой длины (одинаковой для всех векторов, входящих в этот список). Так они одинаковой длины, то их можно «поставить рядом друг с другом» как колонки матрицы. Собственно, так и получается. Вот только в данному случае разные столбцы могут содержать разный тип данных.</p>
<p>И тем не менее, поскольку датафрейм наследует свойства обоих своих «родителей», обращаться с ним можно и как со списком, и как с матрицей:</p>
<p>str(df) # изучаем структуру ## ‘data.frame’: 5 obs. of 4 variables: ## $ name: chr “Илья” “Алёна” “Виктор” “Елена” … ## $ age : num 21 34 19 52 26 ## $ sex : chr “муж” “жен” “муж” “жен” … ## $ city: chr “Орёл” “Тверь” “Тирасполь” “Питер” … df<span class="math inline">\(name # вытаскиваем элемент списка (вектор имён респондентов)
## [1] "Илья"     "Алёна"    "Виктор"   "Елена"    "Кристина"
df\)</span>name[1:3] # индексируем вектор имён респондентов ## [1] “Илья” “Алёна” “Виктор” df[, 1] # так тоже срабоает ## [1] “Илья” “Алёна” “Виктор” “Елена” “Кристина” df[1] # и даже так, но какая структура данных вернулась? ## name ## 1 Илья ## 2 Алёна ## 3 Виктор ## 4 Елена ## 5 Кристина df[1:2, 3:4] # ну это просто пушка ## sex city ## 1 муж Орёл ## 2 жен Тверь Можно добавить новые переменные:</p>
<p>df$married &lt;- FALSE # recycling has happened Функции См. книжку.</p>
<p>Открытый исходный код В R можно не только написать свои функции, но и посмотреть, как написаны другие, то есть увидеть исходный код. Для этого надо написать название функции и выполнить её как команду (без скобок):</p>
<p>sd # стандартное отклонение — корень из дисперсии ## function (x, na.rm = FALSE) ## sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), ## na.rm = na.rm)) ## &lt;bytecode: 0x7fb7fa7d1870&gt; ## &lt;environment: namespace:stats&gt; lm # функция для построения линейной регрессионной модели ## function (formula, data, subset, weights, na.action, method = “qr”, ## model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, ## contrasts = NULL, offset, …) ## { ## ret.x &lt;- x ## ret.y &lt;- y ## cl &lt;- match.call() ## mf &lt;- match.call(expand.dots = FALSE) ## m &lt;- match(c(“formula”, “data”, “subset”, “weights”, “na.action”, ## “offset”), names(mf), 0L) ## mf &lt;- mf[c(1L, m)] ## mf<span class="math inline">\(drop.unused.levels &lt;- TRUE
##     mf[[1L]] &lt;- quote(stats::model.frame)
##     mf &lt;- eval(mf, parent.frame())
##     if (method == "model.frame")
##         return(mf)
##     else if (method != "qr")
##         warning(gettextf("method = '%s' is not supported. Using 'qr'",
##             method), domain = NA)
##     mt &lt;- attr(mf, "terms")
##     y &lt;- model.response(mf, "numeric")
##     w &lt;- as.vector(model.weights(mf))
##     if (!is.null(w) &amp;&amp; !is.numeric(w))
##         stop("'weights' must be a numeric vector")
##     offset &lt;- model.offset(mf)
##     mlm &lt;- is.matrix(y)
##     ny &lt;- if (mlm)
##         nrow(y)
##     else length(y)
##     if (!is.null(offset)) {
##         if (!mlm)
##             offset &lt;- as.vector(offset)
##         if (NROW(offset) != ny)
##             stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
##                 NROW(offset), ny), domain = NA)
##     }
##     if (is.empty.model(mt)) {
##         x &lt;- NULL
##         z &lt;- list(coefficients = if (mlm) matrix(NA_real_, 0,
##             ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
##             y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
##             0) else ny)
##         if (!is.null(offset)) {
##             z\)</span>fitted.values &lt;- offset ## z<span class="math inline">\(residuals &lt;- y - offset
##         }
##     }
##     else {
##         x &lt;- model.matrix(mt, mf, contrasts)
##         z &lt;- if (is.null(w))
##             lm.fit(x, y, offset = offset, singular.ok = singular.ok,
##                 ...)
##         else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
##             ...)
##     }
##     class(z) &lt;- c(if (mlm) "mlm", "lm")
##     z\)</span>na.action &lt;- attr(mf, “na.action”) ## z<span class="math inline">\(offset &lt;- offset
##     z\)</span>contrasts &lt;- attr(x, “contrasts”) ## z<span class="math inline">\(xlevels &lt;- .getXlevels(mt, mf)
##     z\)</span>call &lt;- cl ## z<span class="math inline">\(terms &lt;- mt
##     if (model)
##         z\)</span>model &lt;- mf ## if (ret.x) ## z<span class="math inline">\(x &lt;- x
##     if (ret.y)
##         z\)</span>y &lt;- y ## if (!qr) ## z$qr &lt;- NULL ## z ## } ## &lt;bytecode: 0x7fb7f6c95f80&gt; ## &lt;environment: namespace:stats&gt; Строки Мы уже знакомились со строковым типом данных character. Но мы обозначили, что многие операции над этим типом невозможны (например, нельзя сложить две строки). Возникает вопрос: что делать?</p>
<p>Для начала научимся ставить дополнительные пакеты.</p>
<p>Установка дополнительных пакетов В самом начале мы упоминали, что R имеет большие возможности расширения функционала с помощью специальных пакетов. Для работы со строками нам будут нужны два — stringi («стринг-ай») и stringr («стринг-ар»). На их примере мы и разберем механизм установки и подключения дополнительных пакетов.</p>
<p>Пакет — это набор функций, не входящих в «базовую комплектацию R», которые, как правило, специализированы под те или иные задачи. В нашем случае — под работу со строками. Поэтому сначала пакет необходимо скачать на комп:</p>
<p>install.packages(c(“stringi”, “stringr”)) В функцию install.packages() необходимо передать строковый вектор, содержащий названия пакетов, которые мы бы хотели установить.</p>
<p>Часто одни пакеты ссылаются на функции других, поэтому можно указать в аргументе dependencies TRUE, чтобы попутно установились зависимые пакеты.</p>
<p>install.packages(c(“stringi”, “stringr”), dependencies = TRUE) По умолчанию пакеты скачиваются с репозитория CRAN — основное хранилище, где лежит подавляющее большинство пакетов и всякого разного. Но может быть такое, что установить соединение с этим репозиторием по каким-либо причинам не получается. Чтобы пофиксить сей баг, нужно указать в настройках какое-либо из зеркал. Options → Packages → Primary CRAN repository → Change…, и выбрать что-то. Если не помогло — попробуйте ещё.</p>
<p>Но мало просто скачать пакет. Надо его ещё подключить к текущей сессии, в которой мы работаем. Для этого используется функция</p>
<p>library(stringi) library(stringr) Ей уже надо скормить название пакета без кавычек, и для подключения каждого пакета потребуется написать новую строчку.</p>
<p>Тут запутываются термины «пакет» и «библиотека», но опустим эти детали и примем сей момент как есть…</p>
<p>После того, как мы подключили пакет к данной сессии, мы можем использовать функции из него.</p>
<p>Кайф, поехали!</p>
<p>Создание строк Можно сделать строку руками (наблюдайте за кавычками):</p>
<p>s1 &lt;- “сложившаяся структура организации влечет за собой процесс внедрения и модернизации новых предложений” s1 ## [1] “сложившаяся структура организации влечет за собой процесс внедрения и модернизации новых предложений” s2 &lt;- ‘С другой стороны постоянный количественный “рост” и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации’ s2 ## [1] “С другой стороны постоянный количественный "рост" и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации” s3 &lt;- “С другой стороны постоянный количественный”рост” и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации” s3 ## Error: <text>:1:52: unexpected symbol ## 1: s3 &lt;- “С другой стороны постоянный количественный”рост ## ^ s4 &lt;- “С другой стороны постоянный количественный ‘рост’ и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации” s4 ## [1] “С другой стороны постоянный количественный ‘рост’ и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации” s5 &lt;- “С другой стороны постоянный количественный «рост» и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации” s5 ## [1] “С другой стороны постоянный количественный «рост» и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации” s6 &lt;- “” # это пустая строка s6 ## [1] “” Также можно использовать функцию character()8 для создания вектора из пустых строк:</text></p>
<p>character(5) ## [1] “” “” “” “” “” А также функции для приведения типов, которые мы уже обсуждали:</p>
<p>as.character(1:30) ## [1] “1” “2” “3” “4” “5” “6” “7” “8” “9” “10” “11” “12” “13” “14” “15” ## [16] “16” “17” “18” “19” “20” “21” “22” “23” “24” “25” “26” “27” “28” “29” “30” Кроме того, существуют встроенные текстовые векторы:</p>
<p>letters ## [1] “a” “b” “c” “d” “e” “f” “g” “h” “i” “j” “k” “l” “m” “n” “o” “p” “q” “r” “s” ## [20] “t” “u” “v” “w” “x” “y” “z” LETTERS ## [1] “A” “B” “C” “D” “E” “F” “G” “H” “I” “J” “K” “L” “M” “N” “O” “P” “Q” “R” “S” ## [20] “T” “U” “V” “W” “X” “Y” “Z” Есть ещё встроенные векторы, которые содержат названия месяцев и аббревиатуры названий месяцев. Можете их отыскать.</p>
<p>Мы умеем генерировать числавые последовательности. Можно также генерировать и строки. Например, когда вы хотите сгенерировать ID для испытуемых не просто как числа, а как уникальные текстовые значения:</p>
<p>stri_rand_strings(n = 10, length = 5) ## [1] “DDOwx” “jjX0b” “pkSXX” “0MbpM” “PZaiO” “uxEiu” “bdwqZ” “o7lc9” “4Smjo” ## [10] “AwI9i” Фнукции из пакета stringi начинаются с префикса stri, а функции пакета stringr — с префикса str. Их легко можно опознать.</p>
<p>Конкатенация строк Строки можно соединять воедино:</p>
<p>paste(‘first’, ‘second’, ‘third’) # базовый R ## [1] “first second third” paste(‘first’, ‘second’, ‘third’, sep = “_“) ## [1]”first_second_third” paste0(‘first’, ‘second’, ‘third’) ## [1] “firstsecondthird” stri_c(‘first’, ‘second’, ‘third’) # пакет stringi ## [1] “firstsecondthird” stri_c(‘first’, ‘second’, ‘third’, sep = ” &amp; “) # пакет stringi ## [1]”first &amp; second &amp; third” Разделение строк Если добрый коллега записал экспериментальные условия в одну переменную как выше, а вам нужно делать по ним, например, какую-нибудь анову, то можно на него долго ругаться, а можно разделить строки обратно:</p>
<p>s_exp &lt;- paste(‘first’, ‘second’, ‘third’, sep = “<em>”) s_exp ## [1] ”first_second_third” str_split(s_exp, pattern = ”</em>”) ## [[1]] ## [1] “first” “second” “third” Нам вернулся список. Шо с ним делать — вопрос хороший. Можно развернуть список в вектор и индексацией вытащить нужные нам части.</p>
<p>Но есть более удобная функция separate(), которая разбивает субстроки сразу по колонкам. Её мы вспомним, когда будет говорить о предобработке данных.</p>
<p>Сортировка строк Строки можно сортировать:</p>
<p>unsorted_s &lt;- paste0( sample(LETTERS, size = length(LETTERS), replace = TRUE), sample(letters, size = length(letters)), sample(letters, size = length(letters)) ) # делаем несортированный вектор из трёхбуквенных «слов» unsorted_s ## [1] “Xbz” “Aja” “Ywe” “Ylc” “Siv” “Qam” “Nzk” “Ntq” “Okd” “Fnt” “Xsy” “Oxi” ## [13] “Kpp” “Eru” “Pyl” “Qvn” “Vfr” “Qes” “Rqo” “Buh” “Fgj” “Vmb” “Fcw” “Fhf” ## [25] “Tdx” “Oog” Сортируем:</p>
<p>sort(unsorted_s) # можно базовой функцией ## [1] “Aja” “Buh” “Eru” “Fcw” “Fgj” “Fhf” “Fnt” “Kpp” “Ntq” “Nzk” “Okd” “Oog” ## [13] “Oxi” “Pyl” “Qam” “Qes” “Qvn” “Rqo” “Siv” “Tdx” “Vfr” “Vmb” “Xbz” “Xsy” ## [25] “Ylc” “Ywe” str_sort(unsorted_s) # можно функцией из пакета stringr ## [1] “Aja” “Buh” “Eru” “Fcw” “Fgj” “Fhf” “Fnt” “Kpp” “Ntq” “Nzk” “Okd” “Oog” ## [13] “Oxi” “Pyl” “Qam” “Qes” “Qvn” “Rqo” “Siv” “Tdx” “Vfr” “Vmb” “Xbz” “Xsy” ## [25] “Ylc” “Ywe” Строки сортируются в лексикографическом порядке. Обратите внимание, что порядок сортировки зависит от того, в какой локали мы работаем, то есть от того, алфавит какого языка используется для определения лексикографического порядка:</p>
<p>str_sort(c(“э”, “а”, “у”, “i”), locale = ‘en’) # по умолчанию ## [1] “i” “а” “у” “э” str_sort(c(“э”, “а”, “у”, “i”), locale = ‘ru’) # русский ## [1] “а” “у” “э” “i” Сортировок существует много разных. Но чем больше у вас данные, тем медленнее будет работать базовый sort(). Поэтому используйте str_sort().</p>
<p>Изменение регистра Допусти вы собирали данные онлайн, и у вас было поле ступень образования, в которой респонденты должны быть указать бакалавриат/магистратура/аспирантура. Но по каким-то причинам, разработчик онлайн-формы не подумал, что хорошо бы сделать это поле списком, из котрого можно выбирать, и оставил его как обычное текстовое поле. Теперь у вас в данных есть «бакалавриат», «Бакалавриат» и какой-нибудь «БАкалавриат», то вообще-то одно и то же. Напасти подобного рода можно победить, если привести строки к единому регистру:</p>
<p>str_to_lower(c(“Бакалавриат”, “БАКАЛАВРИАТ”, “АСпирантура”, “магистратура”)) ## [1] “бакалавриат” “бакалавриат” “аспирантура” “магистратура” str_to_upper(c(“Бакалавриат”, “БАКАЛАВРИАТ”, “АСпирантура”, “магистратура”)) ## [1] “БАКАЛАВРИАТ” “БАКАЛАВРИАТ” “АСПИРАНТУРА” “МАГИСТРАТУРА” Но при таком способе сбора данных могли возникнуть и другие ошибки, так что лучше задуматься об их предотвращении заранее!</p>
<p>Поиск подстроки Если нам надо найти какую-то подстроку, то мы можем использоваться функцию str_detect():</p>
<p>str_detect(unsorted_s, ‘b’) # ищем все элементы, в которых есть маленькая «b» ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [25] FALSE FALSE unsorted_s[str_detect(unsorted_s, ‘b’)] # а вот и сами элементы ## [1] “Xbz” “Vmb” Можно подсчитать число вхождений подстроки в строке:</p>
<p>str_count(unsorted_s, ‘a’) ## [1] 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Изменение строк Раз мы умеем искать подстроку, то, наверное, её можно и как-то изменять.</p>
<p>Выделение подстроки str_sub(unsorted_s, start = 1, end = 2) # по индексам ## [1] “Xb” “Aj” “Yw” “Yl” “Si” “Qa” “Nz” “Nt” “Ok” “Fn” “Xs” “Ox” “Kp” “Er” “Py” ## [16] “Qv” “Vf” “Qe” “Rq” “Bu” “Fg” “Vm” “Fc” “Fh” “Td” “Oo” Замена подстроки str_replace(unsorted_s, pattern = “b”, replacement = “Ц”) ## [1] “XЦz” “Aja” “Ywe” “Ylc” “Siv” “Qam” “Nzk” “Ntq” “Okd” “Fnt” “Xsy” “Oxi” ## [13] “Kpp” “Eru” “Pyl” “Qvn” “Vfr” “Qes” “Rqo” “Buh” “Fgj” “VmЦ” “Fcw” “Fhf” ## [25] “Tdx” “Oog” Удаление подстроки str_remove(unsorted_s, ‘b’) ## [1] “Xz” “Aja” “Ywe” “Ylc” “Siv” “Qam” “Nzk” “Ntq” “Okd” “Fnt” “Xsy” “Oxi” ## [13] “Kpp” “Eru” “Pyl” “Qvn” “Vfr” “Qes” “Rqo” “Buh” “Fgj” “Vm” “Fcw” “Fhf” ## [25] “Tdx” “Oog” Транслитерация строк stri_trans_general(“русский текст, который должен быть написан латиницей”, ‘cyrillic-latin’) ## [1] “russkij tekst, kotoryj dolžen bytʹ napisan latinicej” Регулярные выражения Но часто нас интересует не конкретная подстрока, и все варианты подстрок, которые имеют определенную структуру. Например, мы хотим найти корректно введенные даты рождения в нашем датасете. Пусть по условию дата должна иметь формат DD.MM.YYYY. И у нас есть вот такой вектор:</p>
<p>dates &lt;- c(‘21.92.2001’, ‘01.04.1994’, ‘5-3-2011’, ‘6/04/1999’) Ну, так как у нас сейчас совсем игрушечные данные, мы можем смотреть на них глазами и видеть, что у нас в прицнипе три адекватные даты, но записаны по-разному, и одна верного формата, но с 92 месяцем.</p>
<p>Чтобы задать структуру паттерна, который мы хотим найти, используются регулярные выражения.</p>
<p>Чтобы отображать их работу, будем пользоваться функцией str_view_all().</p>
<p>Метасимволы Если мы попробуем поискать точки в наших датах, то просто так мы их не найдем:</p>
<p>str_view_all(dates, pattern = “.”) 21.92.2001 01.04.1994 5-3-2011 6/04/1999 Подсветились все символы, так как точка в регулярных выражениях — специальный символ. Поэтому чтобы указать, что нас интересуют собственно точки, нужно их экранировать.</p>
<p>str_view_all(dates, pattern = ‘\.’) 21.92.2001 01.04.1994 5-3-2011 6/04/1999 Так лучше. Еще к специальным знакам (метасимфолам) относятся $, *, +, ?, ^, [, ], и другие.</p>
<p>Классы знаков В датах нас интересуют цифры, и для них есть специальное обозначение:</p>
<p>str_view_all(dates, pattern = ‘\d’) # ищем цифры 21.92.2001 01.04.1994 5-3-2011 6/04/1999 str_view_all(dates, pattern = ‘\D’) # ищем не-цифры 21.92.2001 01.04.1994 5-3-2011 6/04/1999 Другие классы символов можно найти в следующих примерах:</p>
<p>str_view_all(‘успешный балбес’, ‘\s’) # пробелы успешный балбес str_view_all(‘успешный балбес’, ‘\S’) # не-пробелы успешный балбес str_view_all(‘верно ведь, что здесь что-то есть’, ‘\w’) # не пробелы и не знаки препинания верно ведь, что здесь что-то есть str_view_all(‘верно ведь, что здесь что-то есть’, ‘\W’) # пробелы и знаки препинания верно ведь, что здесь что-то есть Квантификация Можно указать, сколько раз должен встречаться тот или иной символ:</p>
<p>? — ноль или один раз * — ноль или более раз + — один или более раз {n} — n раз Например, найдем все группировки по два числа:</p>
<p>str_view_all(dates, ‘\d{2}’) 21.92.2001 01.04.1994 5-3-2011 6/04/1999 Итак, теперь мы можем вытащить все корректные даты, которые есть в нашем векторе:</p>
<p>str_view_all(dates, ‘\d{2}\.[01]\d{1}\.\d{4}’) 21.92.2001 01.04.1994 5-3-2011 6/04/1999 Она получилась всего одна. Но в целом в нашим набором условий это справедливо.</p>
<p>Работа с реальными данными Работу с реальными данными мы будем обсуждать в ходе курса. Сейчас же я хочу, чтобы вы попробовали выполнить саму первую задачу при работе с данными — чтение данных. Это первое, где можно существенно встрять и с чем надо уметь разбираться. Мы будем тренироваться на данных о фильмах и сериалах Netflix.</p>
<p>Импорт данных Окей, файл с данными у нас есть. Теперь наша задача его как-то загрузить в R, чтобы мы могли с ним работать. Вариантов существует несколько. Разберём сначала следующий.</p>
<p>переложите скачанный файл из «Загрузок» в папку data обратите внимание на расширение этого файла: netflix_title.csv Такие файлы можно прочитать с помощью функции read.csv(). В аргументах это функции надо указать файл, который надо прочитать (а также путь к нему, начиная с подпапки рабочей директории). То есть:</p>
<p>netflix &lt;- read.csv(‘data/netflix_titles.csv’) Почему так? Так как мы установили рабочую директорию (или запустили проект), то R по умолчанию теперь смотрит в папку нашего курса. А вот далее его надо сориентировать — поэтому мы пишем data/netflix_titles.csv. То есть говорим ему: «иди дальше в папку data и принеси мне файл netflix_titles.csv. Собственно, он нам его и принёс.</p>
<p>Можно это проверить:</p>
<p>head(netflix) ## show_id type title director ## 1 s1 TV Show 3%<br>
## 2 s2 Movie 7:19 Jorge Michel Grau ## 3 s3 Movie 23:59 Gilbert Chan ## 4 s4 Movie 9 Shane Acker ## 5 s5 Movie 21 Robert Luketic ## 6 s6 TV Show 46 Serdar Akar ## cast ## 1 João Miguel, Bianca Comparato, Michel Gomes, Rodolfo Valente, Vaneza Oliveira, Rafael Lozano, Viviane Porto, Mel Fronckowiak, Sergio Mamberti, Zezé Motta, Celso Frateschi ## 2 Demián Bichir, Héctor Bonilla, Oscar Serrano, Azalia Ortiz, Octavio Michel, Carmen Beato ## 3 Tedd Chan, Stella Chung, Henley Hii, Lawrence Koh, Tommy Kuan, Josh Lai, Mark Lee, Susan Leong, Benjamin Lim ## 4 Elijah Wood, John C. Reilly, Jennifer Connelly, Christopher Plummer, Crispin Glover, Martin Landau, Fred Tatasciore, Alan Oppenheimer, Tom Kane ## 5 Jim Sturgess, Kevin Spacey, Kate Bosworth, Aaron Yoo, Liza Lapira, Jacob Pitts, Laurence Fishburne, Jack McGee, Josh Gad, Sam Golzari, Helen Carey, Jack Gilpin ## 6 Erdal Beşikçioğlu, Yasemin Allen, Melis Birkan, Saygın Soysal, Berkan Şal, Metin Belgin, Ayça Eren, Selin Uludoğan, Özay Fecht, Suna Yıldızoğlu ## country date_added release_year rating duration ## 1 Brazil August 14, 2020 2020 TV-MA 4 Seasons ## 2 Mexico December 23, 2016 2016 TV-MA 93 min ## 3 Singapore December 20, 2018 2011 R 78 min ## 4 United States November 16, 2017 2009 PG-13 80 min ## 5 United States January 1, 2020 2008 PG-13 123 min ## 6 Turkey July 1, 2017 2016 TV-MA 1 Season ## listed_in ## 1 International TV Shows, TV Dramas, TV Sci-Fi &amp; Fantasy ## 2 Dramas, International Movies ## 3 Horror Movies, International Movies ## 4 Action &amp; Adventure, Independent Movies, Sci-Fi &amp; Fantasy ## 5 Dramas ## 6 International TV Shows, TV Dramas, TV Mysteries ## description ## 1 In a future where the elite inhabit an island paradise far from the crowded slums, you get one chance to join the 3% saved from squalor. ## 2 After a devastating earthquake hits Mexico City, trapped survivors from all walks of life wait to be rescued while trying desperately to stay alive. ## 3 When an army recruit is found dead, his fellow soldiers are forced to confront a terrifying secret that’s haunting their jungle island training camp. ## 4 In a postapocalyptic world, rag-doll robots hide in fear from dangerous machines out to exterminate them, until a brave newcomer joins the group. ## 5 A brilliant group of students become card-counting experts with the intent of swindling millions out of Las Vegas casinos by playing blackjack. ## 6 A genetics professor experiments with a treatment for his comatose sister that blends medical and shamanic cures, but unlocks a shocking side effect. Что-то загрузилось. Это хорошо. Что именно — выясним чуть позже.</p>
<p>Можно ли не прописывать data? Можно, но тогда придётся переложить файл данных в рабочую директорию (то есть папку курса). С одним файлом ничего, можно жить. А есть у вас 30 или 50 файлов разных респондентов? Уже тяжеловато и бардак. Поэтому, на мой взгляд, такая организация — хороший компромисс: кода пишем чуть-чуть больше, но зато есть порядок.</p>
<p>Конечно, можно хранить файлы данных где-то совсем отдельно. Но тогда и прописывать придётся путь от конревой папки компа:</p>
</section>
<section id="например-можно-прочитать-файл-прямо-из-папки-загрузки" class="level1" data-number="24">
<h1 data-number="24"><span class="header-section-number">24</span> например, можно прочитать файл прямо из папки «Загрузки»</h1>
<p>netflix &lt;- read.csv(‘/Users/antonangelgardt/Downloads/netflix_titles.csv’) Это выглядит не очень удобно.</p>
<p>На самом деле, в мире облачных технологий можно и вовсе обойтись без скачивания файлов на десктоп. Функция read.csv() вполне может прочитать файл прямо из интернета:</p>
</section>
<section id="это-ссылка-на-мой-github-где-лежит-нужный-нам-файл" class="level1" data-number="25">
<h1 data-number="25"><span class="header-section-number">25</span> это ссылка на мой GitHub, где лежит нужный нам файл</h1>
<p>netflix &lt;- read.csv(‘https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/data/netflix_titles.csv’) Однако стоит помнить, что наши собранные руками данные в облаках, скорее всего, не лежат. Поэтому надо уметь загрузить файл и из интернета, и с компа.</p>
<p>Форматы данных Мы тактично соскользнули с момента расширения файла. Напомню, что у нас файл netflix_titles.csv. Пришло время уделить этому внимание.</p>
<p>Мы говорили о типах данных, о структурах данных — а теперь поговорим о форматах данных.</p>
<p>Формат данных — это характеристика данных, которая определяет много чего:</p>
<p>какие программы могут работать с этим файлом как структурирован файл внутри как структурированный файл разбирается на неструктирированные последовательности байтов (для хранения в памяти компьютера) и преобразуются обратно… Ну, короче куча-куча всего. Формат файла (не вдаваясь в детали) задаётся его разширением, то есть тем, что написано после точки в его названии (.R, .doc, .xlsx, .xml, .txt, …).</p>
<p>Нас, прежде всего, интересуют файлы данных, поэтому об их форматах мы и поговорим.</p>
<p>Текстовые форматы Проще всего хранить данные в тексте. Это удобно, такие файлы мало весят и в них можно поместить большое количество информации. Самый простой текстовый формат — это .txt. Это тот самый «Блокнот», с которым наверняка когда-то все сталкивались. Никакого форматирования, никакой лишней мишуры — только текст. Но нам ведь нужно из этого текста каким-то образом потом вытащить датафрейм. Для этого существуют разделители. Чаще всего в табличных .txt формате столбцы таблицы разделены между собой символами табуляции (‘’), а строки — символом переноса строки (‘’). Файл .txt. можно считать с помощью функции read.table():</p>
<p>df &lt;- read.table(‘data/text_data.txt’) # это данные про качесво красного вина # так как у вас нет отдельно скачанного этого датасета, то запустите вот эту команду, чтобы прочитать текстовый файл # read.table() тоже умеет читать прямо из интернета df &lt;- read.table(‘https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/text_data.txt’) Если использовать другие разделители, например, запятую, то получится файл, содержащий значения, разделённые запятыми (comma separated values). Это и есть .csv-файлы, с которыми мы будем чаще всего работать.</p>
<p>Несмотря на то, что по умолчанию операционная система пытается открыть CSV-шки в табличном редакторе (например, Excel), не надо на это вестись! CSV — это текстовый формат данных.</p>
<p>По умолчанию, в CSV-файле столбцы разделяются запятыми, а строки — символом переноса строки, поэтому функция read.csv() имеет соответствующие дефолтные настройки. Однако так бывает не всегда. Например, попробуем прочесть следующий файл:</p>
</section>
<section id="снова-про-качество-вина" class="level1" data-number="26">
<h1 data-number="26"><span class="header-section-number">26</span> снова про качество вина</h1>
<p>wine &lt;- read.csv(‘https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/winequality-red.csv’) Файл CSV-шный. Посмотрим, что получилось:</p>
<p>head(wine) # команда выводит часть датасета в консоль ## fixed.acidity.volatile.acidity.citric.acid.residual.sugar.chlorides.free.sulfur.dioxide.total.sulfur.dioxide.density.pH.sulphates.alcohol.quality ## 1 7.4;0.7;0;1.9;0.076;11;34;0.9978;3.51;0.56;9.4;5 ## 2 7.8;0.88;0;2.6;0.098;25;67;0.9968;3.2;0.68;9.8;5 ## 3 7.8;0.76;0.04;2.3;0.092;15;54;0.997;3.26;0.65;9.8;5 ## 4 11.2;0.28;0.56;1.9;0.075;17;60;0.998;3.16;0.58;9.8;6 ## 5 7.4;0.7;0;1.9;0.076;11;34;0.9978;3.51;0.56;9.4;5 ## 6 7.4;0.66;0;1.8;0.075;13;40;0.9978;3.51;0.56;9.4;5 Что-то получилось. Но мы хотели увидеть нечто, напоминающее таблицу (вернее, датафрейм), а получилось явно что-то не то… Почему так? Потому что расширение .csv ещё не гарант того, что в файле в качестве разделителя использовалась запятая. Глобально — это может быть вообще любой знак. В данном случае была использована точка с запятой. Если мы немного изменим команду и вручную укажем разделитель (separator), то всё будет ок:</p>
<p>wine &lt;- read.csv(‘https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/winequality-red.csv’, sep = ‘;’) head(wine) ## fixed.acidity volatile.acidity citric.acid residual.sugar chlorides ## 1 7.4 0.70 0.00 1.9 0.076 ## 2 7.8 0.88 0.00 2.6 0.098 ## 3 7.8 0.76 0.04 2.3 0.092 ## 4 11.2 0.28 0.56 1.9 0.075 ## 5 7.4 0.70 0.00 1.9 0.076 ## 6 7.4 0.66 0.00 1.8 0.075 ## free.sulfur.dioxide total.sulfur.dioxide density pH sulphates alcohol ## 1 11 34 0.9978 3.51 0.56 9.4 ## 2 25 67 0.9968 3.20 0.68 9.8 ## 3 15 54 0.9970 3.26 0.65 9.8 ## 4 17 60 0.9980 3.16 0.58 9.8 ## 5 11 34 0.9978 3.51 0.56 9.4 ## 6 13 40 0.9978 3.51 0.56 9.4 ## quality ## 1 5 ## 2 5 ## 3 5 ## 4 6 ## 5 5 ## 6 5 Вот теперь хорошо.</p>
<p>Табличные форматы Данные могут храниться и в табличных форматах — это привычные нам Excel-таблицы с расширениями .xls и .xlsx. Поскольку это уже не текст, а именно таблица, то и вопросов с разделителями здесь не возникает. Однако, как мы знаем, Excel books могут состоять из нескольких листов, и данные могут располагаться на любом из них, хотя, конечно, чаще всего они располагаются на первом листе. Функций для импорта табличных данных существует несколько, я предлагаю вам вот эту:</p>
<p>df &lt;- readxl::read_excel(‘path/to/file.xlsx’, sheet = 2) Здесь мы уже привычно задаем в качестве первого аргумента путь к файлу, а вторым (опциональным) аргументом можно указать номер листа, с которого нужно считать данные. По умолчанию этот аргумент равен 1 .</p>
<p>Заметьте ещё одну особенность обращения к функциям из внешних пакетов. Если нам нужна только одна функция из пакета, то не обязательно погружать весь пакет к сессии через функцию library(). Можно указать название пакета9, из которого нам нужна функция, далее поставить два двоеточия10 и затем использовать функцию, которая нам нужна.</p>
<p>Форматы данных с особой разметкой Есть и более экзотичные персонажи в мире форматов данных. Таковы, например, .json и .xml. Они главным образом заточены под передачу даных в интернете, поэтому если мы не соприкасаетесь с данной областью напрямую, то, скорее всего, не столкнетесь с ними никогда. Однако для общего представления будет полезно знать о том, что такие звери существуют.</p>
<p>Как импортируется JSON можно посмотреть тут, а про XML есть здесь.</p>
<p>Файлы данных других статистических программ В нашей исследовательской области всё ещё остаются активно распространены другие статистические программы, например, SPSS. И вы вполне можете столкнуться с необходимостью чтения данных из файлов формата .sav — это специальные файлы данных программы SPSS. В целом, в них нет чего-либо супернеобычного, однако есть некоторые особенности.</p>
<p>Для их чтения потребуется пакет foreign11:</p>
<p>df &lt;- foreign::read.spss(‘path/to/file.sav’, use.value.labels = TRUE, to.data.frame = TRUE, use.missings = TRUE) Из всего пакета нам снова нужна только одна функция, которая импортирует файлы .sav. Можно наблюдать, что она хочет ряд дополнительных аргументов. Они не обязательные, но чтобы быть уверенным в корректном импорте, лучше их прописать. use.value.labels определяет загрузку факторным переменных, to.data.frame говорит, что мы хотим получить на выходе датафрейм (если указать FALSE, то будет список), use.missings означает, что вместо пропусков будут указаны NA (а нам это надо).</p>
<p>Исследование данных Мы вдоволь наговорились о форматах данных. Теперь попробуем поработать с тем, что у нас есть. Напомню, что мы загрузили данные о фильмах и сериалах Netflix в переменную netflix.</p>
<p>Когда мы загрузили датасет, нам, прежде всего, хочется посмотреть, как оно выглядит. Это можно сделать несколькими способами. Если мы хотим более привычный для неискущённого пользователя вариант, то можно воспользоваться командой View() (именно с заглавной):</p>
<p>View(netflix) В соседней вкладке откроется датасет в привычном табличном виде, и можно будет посмотреть, корректно ли прочитались данные. Вариант удобный, но если у вас датасет в 1000 строк, «отсматривать глазами» косяки чтения данных совершенно бессмысленно.</p>
<p>Можно вывести первые несколько строк датасета в консоль — это мы уже делали:</p>
<p>head(netflix) ## show_id type title director ## 1 s1 TV Show 3%<br>
## 2 s2 Movie 7:19 Jorge Michel Grau ## 3 s3 Movie 23:59 Gilbert Chan ## 4 s4 Movie 9 Shane Acker ## 5 s5 Movie 21 Robert Luketic ## 6 s6 TV Show 46 Serdar Akar ## cast ## 1 João Miguel, Bianca Comparato, Michel Gomes, Rodolfo Valente, Vaneza Oliveira, Rafael Lozano, Viviane Porto, Mel Fronckowiak, Sergio Mamberti, Zezé Motta, Celso Frateschi ## 2 Demián Bichir, Héctor Bonilla, Oscar Serrano, Azalia Ortiz, Octavio Michel, Carmen Beato ## 3 Tedd Chan, Stella Chung, Henley Hii, Lawrence Koh, Tommy Kuan, Josh Lai, Mark Lee, Susan Leong, Benjamin Lim ## 4 Elijah Wood, John C. Reilly, Jennifer Connelly, Christopher Plummer, Crispin Glover, Martin Landau, Fred Tatasciore, Alan Oppenheimer, Tom Kane ## 5 Jim Sturgess, Kevin Spacey, Kate Bosworth, Aaron Yoo, Liza Lapira, Jacob Pitts, Laurence Fishburne, Jack McGee, Josh Gad, Sam Golzari, Helen Carey, Jack Gilpin ## 6 Erdal Beşikçioğlu, Yasemin Allen, Melis Birkan, Saygın Soysal, Berkan Şal, Metin Belgin, Ayça Eren, Selin Uludoğan, Özay Fecht, Suna Yıldızoğlu ## country date_added release_year rating duration ## 1 Brazil August 14, 2020 2020 TV-MA 4 Seasons ## 2 Mexico December 23, 2016 2016 TV-MA 93 min ## 3 Singapore December 20, 2018 2011 R 78 min ## 4 United States November 16, 2017 2009 PG-13 80 min ## 5 United States January 1, 2020 2008 PG-13 123 min ## 6 Turkey July 1, 2017 2016 TV-MA 1 Season ## listed_in ## 1 International TV Shows, TV Dramas, TV Sci-Fi &amp; Fantasy ## 2 Dramas, International Movies ## 3 Horror Movies, International Movies ## 4 Action &amp; Adventure, Independent Movies, Sci-Fi &amp; Fantasy ## 5 Dramas ## 6 International TV Shows, TV Dramas, TV Mysteries ## description ## 1 In a future where the elite inhabit an island paradise far from the crowded slums, you get one chance to join the 3% saved from squalor. ## 2 After a devastating earthquake hits Mexico City, trapped survivors from all walks of life wait to be rescued while trying desperately to stay alive. ## 3 When an army recruit is found dead, his fellow soldiers are forced to confront a terrifying secret that’s haunting their jungle island training camp. ## 4 In a postapocalyptic world, rag-doll robots hide in fear from dangerous machines out to exterminate them, until a brave newcomer joins the group. ## 5 A brilliant group of students become card-counting experts with the intent of swindling millions out of Las Vegas casinos by playing blackjack. ## 6 A genetics professor experiments with a treatment for his comatose sister that blends medical and shamanic cures, but unlocks a shocking side effect. По умолчанию выводится шесть строк, однако этот парамент можно задать вручную:</p>
<p>head(netflix, n = 4) ## show_id type title director ## 1 s1 TV Show 3%<br>
## 2 s2 Movie 7:19 Jorge Michel Grau ## 3 s3 Movie 23:59 Gilbert Chan ## 4 s4 Movie 9 Shane Acker ## cast ## 1 João Miguel, Bianca Comparato, Michel Gomes, Rodolfo Valente, Vaneza Oliveira, Rafael Lozano, Viviane Porto, Mel Fronckowiak, Sergio Mamberti, Zezé Motta, Celso Frateschi ## 2 Demián Bichir, Héctor Bonilla, Oscar Serrano, Azalia Ortiz, Octavio Michel, Carmen Beato ## 3 Tedd Chan, Stella Chung, Henley Hii, Lawrence Koh, Tommy Kuan, Josh Lai, Mark Lee, Susan Leong, Benjamin Lim ## 4 Elijah Wood, John C. Reilly, Jennifer Connelly, Christopher Plummer, Crispin Glover, Martin Landau, Fred Tatasciore, Alan Oppenheimer, Tom Kane ## country date_added release_year rating duration ## 1 Brazil August 14, 2020 2020 TV-MA 4 Seasons ## 2 Mexico December 23, 2016 2016 TV-MA 93 min ## 3 Singapore December 20, 2018 2011 R 78 min ## 4 United States November 16, 2017 2009 PG-13 80 min ## listed_in ## 1 International TV Shows, TV Dramas, TV Sci-Fi &amp; Fantasy ## 2 Dramas, International Movies ## 3 Horror Movies, International Movies ## 4 Action &amp; Adventure, Independent Movies, Sci-Fi &amp; Fantasy ## description ## 1 In a future where the elite inhabit an island paradise far from the crowded slums, you get one chance to join the 3% saved from squalor. ## 2 After a devastating earthquake hits Mexico City, trapped survivors from all walks of life wait to be rescued while trying desperately to stay alive. ## 3 When an army recruit is found dead, his fellow soldiers are forced to confront a terrifying secret that’s haunting their jungle island training camp. ## 4 In a postapocalyptic world, rag-doll robots hide in fear from dangerous machines out to exterminate them, until a brave newcomer joins the group. Аналогично можно вывести несколько последних строк:</p>
<p>tail(netflix, n = 9) ## show_id type title director ## 7779 s7779 Movie Zombieland Ruben Fleischer ## 7780 s7780 TV Show Zona Rosa<br>
## 7781 s7781 Movie Zoo Shlok Sharma ## 7782 s7782 Movie Zoom Peter Hewitt ## 7783 s7783 Movie Zozo Josef Fares ## 7784 s7784 Movie Zubaan Mozez Singh ## 7785 s7785 Movie Zulu Man in Japan<br>
## 7786 s7786 TV Show Zumbo’s Just Desserts<br>
## 7787 s7787 Movie ZZ TOP: THAT LITTLE OL’ BAND FROM TEXAS Sam Dunn ## cast ## 7779 Jesse Eisenberg, Woody Harrelson, Emma Stone, Abigail Breslin, Amber Heard, Bill Murray, Derek Graf ## 7780 Manu NNa, Ana Julia Yeyé, Ray Contreras, Pablo Morán ## 7781 Shashank Arora, Shweta Tripathi, Rahul Kumar, Gopal K. Singh, Yogesh Kurme, Prince Daniel ## 7782 Tim Allen, Courteney Cox, Chevy Chase, Kate Mara, Ryan Newman, Michael Cassidy, Spencer Breslin, Rip Torn, Kevin Zegers ## 7783 Imad Creidi, Antoinette Turk, Elias Gergi, Carmen Lebbos, Viktor Axelsson, Charbel Iskandar, Yasmine Awad ## 7784 Vicky Kaushal, Sarah-Jane Dias, Raaghav Chanana, Manish Chaudhary, Meghna Malik, Malkeet Rauni, Anita Shabdish, Chittaranjan Tripathy ## 7785 Nasty C ## 7786 Adriano Zumbo, Rachel Khoo ## 7787<br>
## country ## 7779 United States ## 7780 Mexico ## 7781 India ## 7782 United States ## 7783 Sweden, Czech Republic, United Kingdom, Denmark, Netherlands ## 7784 India ## 7785<br>
## 7786 Australia ## 7787 United Kingdom, Canada, United States ## date_added release_year rating duration ## 7779 November 1, 2019 2009 R 88 min ## 7780 November 26, 2019 2019 TV-MA 1 Season ## 7781 July 1, 2018 2018 TV-MA 94 min ## 7782 January 11, 2020 2006 PG 88 min ## 7783 October 19, 2020 2005 TV-MA 99 min ## 7784 March 2, 2019 2015 TV-14 111 min ## 7785 September 25, 2020 2019 TV-MA 44 min ## 7786 October 31, 2020 2019 TV-PG 1 Season ## 7787 March 1, 2020 2019 TV-MA 90 min ## listed_in ## 7779 Comedies, Horror Movies ## 7780 International TV Shows, Spanish-Language TV Shows, Stand-Up Comedy &amp; Talk Shows ## 7781 Dramas, Independent Movies, International Movies ## 7782 Children &amp; Family Movies, Comedies ## 7783 Dramas, International Movies ## 7784 Dramas, International Movies, Music &amp; Musicals ## 7785 Documentaries, International Movies, Music &amp; Musicals ## 7786 International TV Shows, Reality TV ## 7787 Documentaries, Music &amp; Musicals ## description ## 7779 Looking to survive in a world taken over by zombies, a dorky college student teams with an urban roughneck and a pair of grifter sisters. ## 7780 An assortment of talent takes the stage for a night of honest stand-up featuring four of Mexico’s funniest LGBTQ comedians. ## 7781 A drug dealer starts having doubts about his trade as his brother, his client, and two rappers from the slums each battle their own secret addictions. ## 7782 Dragged from civilian life, a former superhero must train a new crop of youthful saviors when the military preps for an attack by a familiar villain. ## 7783 When Lebanon’s Civil War deprives Zozo of his family, he’s left with grief and little means as he escapes to Sweden in search of his grandparents. ## 7784 A scrappy but poor boy worms his way into a tycoon’s dysfunctional family, while facing his fear of music and the truth about his past. ## 7785 In this documentary, South African rapper Nasty C hits the stage and streets of Tokyo, introducing himself to the city’s sights, sounds and culture. ## 7786 Dessert wizard Adriano Zumbo looks for the next “Willy Wonka” in this tense competition that finds skilled amateurs competing for a $100,000 prize. ## 7787 This documentary delves into the mystique behind the blues-rock trio and explores how the enigmatic band created their iconic look and sound. Но мы помним, что датафрейм — это список. А на списках работала функция str(), которая показывала структуру списка. Значит, можно выполнить эту функцию и на датафрейме? Да!</p>
<p>str(netflix) ## ‘data.frame’: 7787 obs. of 12 variables: ## $ show_id : chr “s1” “s2” “s3” “s4” … ## $ type : chr “TV Show” “Movie” “Movie” “Movie” … ## $ title : chr “3%” “7:19” “23:59” “9” … ## $ director : chr “” “Jorge Michel Grau” “Gilbert Chan” “Shane Acker” … ## $ cast : chr “João Miguel, Bianca Comparato, Michel Gomes, Rodolfo Valente, Vaneza Oliveira, Rafael Lozano, Viviane Porto, Me”| <strong>truncated</strong> “Demián Bichir, Héctor Bonilla, Oscar Serrano, Azalia Ortiz, Octavio Michel, Carmen Beato” “Tedd Chan, Stella Chung, Henley Hii, Lawrence Koh, Tommy Kuan, Josh Lai, Mark Lee, Susan Leong, Benjamin Lim” “Elijah Wood, John C. Reilly, Jennifer Connelly, Christopher Plummer, Crispin Glover, Martin Landau, Fred Tatasc”| <strong>truncated</strong> … ## $ country : chr “Brazil” “Mexico” “Singapore” “United States” … ## $ date_added : chr “August 14, 2020” “December 23, 2016” “December 20, 2018” “November 16, 2017” … ## $ release_year: int 2020 2016 2011 2009 2008 2016 2019 1997 2019 2008 … ## $ rating : chr “TV-MA” “TV-MA” “R” “PG-13” … ## $ duration : chr “4 Seasons” “93 min” “78 min” “80 min” … ## $ listed_in : chr “International TV Shows, TV Dramas, TV Sci-Fi &amp; Fantasy” “Dramas, International Movies” “Horror Movies, International Movies” “Action &amp; Adventure, Independent Movies, Sci-Fi &amp; Fantasy” … ## $ description : chr “In a future where the elite inhabit an island paradise far from the crowded slums, you get one chance to join t”| <strong>truncated</strong> “After a devastating earthquake hits Mexico City, trapped survivors from all walks of life wait to be rescued wh”| <strong>truncated</strong> “When an army recruit is found dead, his fellow soldiers are forced to confront a terrifying secret that’s haunt”| <strong>truncated</strong> “In a postapocalyptic world, rag-doll robots hide in fear from dangerous machines out to exterminate them, until”| <strong>truncated</strong> … Тут даже попроще аутпут. Функция выводит структуру датафрейма, в которой отображены количество наблюдений (строк) и количество переменных (столбцов), сами переменные, в нём содержащиеся, их тип, а также первые несколько значений каждой переменной. Это позволяет составить общее представление о том, что есть в наших данных.</p>
<p>Есть ещё одна полезная функция, чтобы понять, всё ли ок с данными:</p>
<p>summary(netflix) ## show_id type title director<br>
## Length:7787 Length:7787 Length:7787 Length:7787<br>
## Class :character Class :character Class :character Class :character<br>
## Mode :character Mode :character Mode :character Mode :character<br>
##<br>
##<br>
##<br>
## cast country date_added release_year ## Length:7787 Length:7787 Length:7787 Min. :1925<br>
## Class :character Class :character Class :character 1st Qu.:2013<br>
## Mode :character Mode :character Mode :character Median :2017<br>
## Mean :2014<br>
## 3rd Qu.:2018<br>
## Max. :2021<br>
## rating duration listed_in description<br>
## Length:7787 Length:7787 Length:7787 Length:7787<br>
## Class :character Class :character Class :character Class :character<br>
## Mode :character Mode :character Mode :character Mode :character<br>
##<br>
##<br>
## Эта функция выводит «саммари» (неужели!) по каждой из переменных датасета. Если переменная числовая, то выводятся базовые описательные статистики (например, как в случае release_year). Наш же датасет оказался богат на строковые переменные, для которых summary() может посчитать только количество наблюдений и указать класс (тип) переменной.</p>
<p>В целом, этого достаточно, чтобы базово проверить, верно ли прочитались данные. А далее нас ждет интересное путешествие в их предобработку и статистический анализ!</p>
<p>Файл .RData Ну, и на последнок нечто, что может вам в определенные моменты облегчить жизнь.</p>
<p>Часто возникает потребность сохранить наработки, когда работа ещё не завершена. Допустим, у вас в Environment накопилась дикая куча объектов, с которыми вы работаете — датафреймы, матрицы, вектора, списки результатов работы статистических функций… — и хотелось бы как-то это все положить на полку, чтобы в следующий раз не перезапускать все 100500 строк кода, которыми вы это множество объектов получили.</p>
<p>Такая возможность есть. Для этого вам нужно сохранить образ вашего Environment. Это делается с помошью функции save.image():</p>
<p>save.image(‘netflix.RData’) В аргументе функции мы указваем название файла, в котором будет лежать этот образ. Файл имеет расширение .RData. Можно прописать какой-либо путь к другому месту на компьютере, но в целом можно и оставить в рабочей директории. Когда понадобится продолжить работу, его будет нужно подгрузить с помощью функции load(),</p>
<p>load(‘netflix.RData’) и продолжать работу с той строки скрипта, на которой вы остановились. Все созданные ранее объекты уже будут в Environment.</p>
<p>При завершении сессии в R он может предложить вам сохранить файл .RData. Не советую это делать — лучше сохранять образ Environment вручную, чтобы знать, что там лежит. Если сохранить файл .RData при выходе по предложению R, то, во-первых, его будет сложно достать, потому что он будет не видим невооруженным глазом в директории (сохраняется как скрытый файл), а во-вторых, он может подгрузиться тогда, когда вы его не просили и сломать вам весь кайф. Придётся числить Environment, прогонять заново код — а оно нам надо? Кажется, нет!</p>
<p>При первом запуске может не быть окна Code Editor. Чтобы его открыть, сделайте File → New File → R Script или нажмите Ctrl + Shift + N (⌘ + Shift + N).↩︎</p>
<p>Чтобы не возникало лишних вопросов, лучше снабдить папку с файлами документом README.md, где описать все важные детали, в том числе и кодировку файла. Об это ещё немного поговорим поздее.↩︎</p>
<p>Бывает, что вот это распространяют и на калькуляторы тоже. [Кек]↩︎</p>
<p>А вообще в разных языках программирования этот вопрос решается по-разному.↩︎</p>
<p>Так-то любой оператор (арифметический или логический) — это функция от двух переменных. В предудщей главе был пример <code>+</code>(7, 3), а теперь попробуйте выполнить <code>&amp;</code>(TRUE, FALSE).↩︎</p>
<p>Хотя, например, для JavaScript сложение строк — стандартная процедура.↩︎</p>
<p>Такие векторы называются свободными.↩︎</p>
<p>Ещё есть numeric() и logical(), например.↩︎</p>
<p>Пакет должен быть установлен (например, через install.packages()).↩︎</p>
<p>Два двоеточия — указание на обращение к определенному пространству имён. В данном случае пространство имён — синоним пакета, так как в разных пакетах могут содержаться функции с одинаковым названием (именем). Такое эксплицитное указание на пакет (пространство имён) также может понадобиться в случае, когда подгруженные функции из внешнего пакета конфликтуют с базовыми, хотя это достаточно редкая история.↩︎</p>
<p>Есть и другие, но этот достаточно прост и интуитивен, как по мне. В нём есть функции не только для чтения SPSS-ных файлов, а ещё куча-куча всего.↩︎</p>
<!-- https://angelgardt.github.io/hse-rs-appandan-2023/r-intro -->


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Скопировано!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Скопировано!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./part-r.html" class="pagination-link" aria-label="Анализ данных в R">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Анализ данных в R</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./r-preproc.html" class="pagination-link" aria-label="Предобработка данных">
        <span class="nav-page-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Предобработка данных</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>