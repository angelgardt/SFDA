# Основы R

Знакомство с R и RStudio
— Я вот не могу выбрать: делать на R или на Python?
— Да какая разница! Главное — делай!

Что это и откуда?
R — популярный язык программирования среди исследователей в социальных и гуманитарных науках. Если совсем коротко, то начиналось всё с языка S, который был языком программирования для статистического анализа. Потом его доработали и получился R.

Хотя сегодня всё ещё можно услышать, что «R — это язык программирования для статистической обработки данных», это ложь. Да, когда-то давно дела обстояли именно так, но сейчас R — это полноценный язык программирования, который позволяет решать широкий спект задач от статистического анализа и data wrangling до машинного обучения, моделирования и создания сайтов и приложений.

Почему R?
свободное ПО (часть GNU Project)
динамично развивается
громадные возможности расширения функционала
более 10 000 пакетов
открытый исходный код
возможность написать свои пакеты

Source

большое сообщество по всему миру, много ресурсов для задавания вопросов
Linear Warriors vs Quadratic Wizards
в SPSS (и другие GUI пакеты) ниже порог вхождения, но развитие навыков — линейное
в R порог вхождения выше, но впоследствии случается резкий буст, и вы становитесь богами дата саенс

Source


репродуцируемость результатов
А он лучше Питона?

Source


Нет. Но он и не хуже.

Вообще файт R vs Python, на мой взгляд, несколько бессмысленный, поскольку, по факту, всё упирается в синтаксис языка. Ну, и запрос работодателя, конечно. Возможности обоих языков и скорость работы сопоставимы. Области применения по большей части тоже. Поэтому я пользуюсь следующей эвристикой:

аналитика, статистика, графики, покрутить данные — R
машинное обучение, нейросети, другой ИИ, интерфейсы и [собственно] программирование — Python
Многие, наверняка, оспорят такое разделение — я же не стану отстаивать его истинность.

Мы будем работать на R, поскольку он всё же более популярен в наших кругах — среди «социально-гуманитарных аналитиков».

Установка R и RStudio
Чтобы нам радостно и приятно жилось, нужно установить:

Сначала R
на Windows
на Mac
на Linux
Затем RStudio
Если что-то не установилось или вы предпочитаете облачные сервисы, то можно работать через браузер в RStudio Cloud.

А зачем обе штуки ставить?
Вопрос не безосновательный. Не углубляясь в мелкие детали, скажем так: R — это собственно язык программирования, а RStudio — это среда (IDE, integrated development environment), которая позволяет в этом языке удобно и просто работать, а также расширяет его возможности.

RStudio — не единственная среда для работы в R, но, определённо, самая топовая. Почти все пользуются именно ею, и нет смысла искать что-то более удобное.

Где спросить вопрос или искать ответ?
Google — препарат выбора
Stack Overflow — ответы на вопросы, и не только по R
Stack Overflow на русском — то же самое, только отечественные специалисты
Cookbook for R — хорошая книжка для старта
RStudio Community — ответы на вопросы по R
R-bloggers — про новинки в R и рядом с ним
Хабр про R
…
Интерфейс RStudio
Итак, посмотрим на RStudio. При запуске у вас откроется что-то такое:


Видно четыре (или три1) окна. Давайте последовательно разбираться, что в каждом из них происходит.

Console
В консоль можно писать команды и запускать их нажатием Enter. Они будут сразу выполняться. После некоторых команд будет выводиться какой-то результат. С помощью стрелок ↑ и ↓ можно вывести предыдущие команды, например, чтобы запустить их ещё раз, не вводя повторно, или каким-либо образом их изменить.

Можно, в прицнипе, работать только из консоли, но на практике это не очень удобно. Главным образом, из-за того, что команды улетают «вникуда» и к некоторым уже будет нельзя вернуться. Поэтому существует редактор кода.

Code Editor
По своей сути это обычный блокнот с той лишь разницей, что здесь некоторые слова раскрашены. И в этом блокноте мы пишем текст программы (скрипт), который состоит из комманд. Чтобы выполнить команду, нам необхожимо отправить её в консоль с помощью Ctrl + Enter (⌘ + Enter). Нажатие Enter здесь как и в обычном текстовом редакторе осуществляет переход на новую строку. Результат выполнения команды отображается в консоли, как будто вы изначально запускали команду там.

В консоли удобно что-то быстро посчитать, скрипт же удобнее при работе с длинными командами и для сохранения кода (текста) для дальнейшей работы. Чтобы сохранить скрипт, сделайте File → Save (as…) или нажмите Ctrl + S (⌘ + S).

Несмотря на то, что файл сохраняется с расширением .R, это всё ещё обычный текст, который можно открыть и редактировать в любом текстовом редакторе (типа Notebook или TextEdit).

Кодировка
Компьютер умеет хранить в памяти только цифры. А текст мы набираем буквами. Поэтому ему приходится перекодировать буквы в цифры. Делать это можно по-разному — поэтому существуют разные кодировки.

При сохранении скрипта важно следить за кодировкой, особенно если в тексте встречаются кириллические знаки. В разных операционных систем разная кодировка по умолчанию, поэтому на другом компьютере файл может открываться с неведомой кракозяброй типа этой:


Обычно при сохрании файла с кириллицей программа автоматически спрашивает, в какой кодировке его надо сохранить. Выбирайте UTF-8 — она корректно откроется в любой операционной системе. Также вы можете сохранить файл в определенной кодировке в помощью File → Save with Encoding….

Если при открытии файла у вас отображается кракозябра, подобная той, которая показана выше, нужно узнать кодировку файла2 (для Win это обычно ASCII, для Mac — UTF-8) и выполнить File → Reopen with Encoding….

Environment (Workspace) и History
Здесь, в Environment, можно наблюдать переменные и другие объекты, которые создаются в процессе работы кода, а также некоторую информацию о них. Это удобно, поскольку код, бывает, разрастается до сумасшедшего количества строк, и что вы там насоздавали тремястами строками выше — уже и не упомнить. А тут всё под рукой.

В окне History можно найти историю команд, которые вы выполняли. Может быть полезно, чтобы не листать консоль, которая, как правило, завалена результатами и ошибками.

Plots, Files, Packages, Help, Viewer
Очень полезное окно в кучей всего.

сюда выводятся графики, которые вы строите
здесь можно найти справку по функциям и пакетам
проверить, какие у вас установлены пакеты и их версии
посмотреть файлы в рабочей директории
наблюдать 3D-визуализации, превью отчетов, презентаций и много чего ещё
R как калькулятор
R — полноценный язык программирования с множеством возможностей, но давайте начнём с малого. Первое, от чего стоит избавиться — это страх консоли. Боязни калькулятора вроде не бывает (но это не точно3), поэтому стартанём с этого.

Арифметические операции
В R есть все привычные нам математические операции и операторы для них: +, -, *, /, ^. Выполняются они тоже вполне предсказуемо:

2 + 5 # сложение
## [1] 7
10 - 4 # вычитание
## [1] 6
3 * 7 # умножение
## [1] 21
30 / 3 # деление
## [1] 10
2 ^ 10 # возведение в степень
## [1] 1024
Также есть два особых деления:

5 %/% 2 # целочисленное деление
## [1] 2
5 %% 2 # взятие остатка от деления (5 mod 2)
## [1] 1

Source


В R есть скобки — (). Их назначение такое же, как и в математике. Порядок выполнения арифметических действий (приоритет операторов4, operator precedence) тоже как в математике. Итого имеем:

4 * 4 + 4
## [1] 20
4 * (4 + 4)
## [1] 32
5 * 5 ^ 5
## [1] 15625
(5 * 5) ^ 5
## [1] 9765625
Так что используйте скобки, если вы не уверены, в каком порядке будут выполняться действия. Или смотрите таблицу приоритета операторов по команде ?Syntax.

Функции
Но что, если нам надо посчитать что-то более сложное? Например, извлечь корень или вычислить логарифм?

Для вычисления подобных штук существуют функции. К вопросу, что есть функция, мы ещё не раз вернемся, а пока ограничимся самым общим пониманием: функция это некоторая команда, которая имеет вид название_функции(), просит что-то указать у себя в скобках (например, число) и после выполнения возвращает нам некоторый ответ (например, снова число).

На примере с квадратным корнем это выглядит так:

sqrt(4)
## [1] 2
R чувствителен к регистру (case-sensitive), то есть SQRT(4) не сработает.

А вот логарифм:

log(16)
## [1] 2.772589
Вот только здесь есть одна важная деталь. Если мы вспомним определение логарифма, то окажется, что
log𝑎𝑏=𝑐⇔𝑎𝑐=𝑏
> Логарифм некоторого числа — это показатель степени, в которую нужно возвести основание, чтобы получить данное число.

Здесь придется чуть углубиться в аргументы функции. Аргументы — это то самое «что-то», что мы записываем в скобках. Бывают обязательные аргументы, без которых функция просто не будет работать и выдаст ошибку, например,

log() # попробуйте выполнить эту команду
и необязательные аргументы, у которых уже задано некоторое значение по умолчанию, например, аргумент base у функции log(), который отвечает как раз за задание основания логарифма.

Список аргументов функции можно посмотреть в справке по данной функции, открыв окно Help и введя в поиск название функции, или выполнив одну из следующих команд:

help(log) # ищет справку по функции
?log # синоним предыдущей команды
Также в справке можно найти много другой полезной информации.

Согласно хелпу, значение по умолчанию равно 𝑒
, то есть вычисляется натуральный логарифм, если основание не указано. Но подождите, в хелпе не написано никакого 𝑒
, там есть что-то странное в виде exp(1). Да, тут спорить бессмысленно, однако exp(1) — это не что иное, как экспонента от единицы, то есть 𝑒1=𝑒
, что равно:

exp(1)
## [1] 2.718282
Итак, мы выучили две важные вещи: (1) функцию exp() и то, что (2) в качестве аргументов функции можно передавать результаты другой функции. Посмотрите примеры:

log(x = 16, base = 2) # эксплицитно задаём основание и число
## [1] 4
log(x = 16, b = 2) # имена аргументов можно не дописывать, если они не совпадают с другими
## [1] 4
log(base = 2, x = 16) # при таком способе задания порядок аргументов можно менять
## [1] 4
log(625, 25) # имя аргумента можно не писать, но тогда соблюдать порядок следования
## [1] 2
log(16, base = exp(sqrt(2))) # задаём аргумент через результат функций
## [1] 1.960516
log10(1000) # десятичный логарифм
## [1] 3
log2(512) # двоичный логарифм
## [1] 9
На логарифмах, естественно, свет клином не сошёлся, есть и множество других функций, например, тригонометрические (sin(), cos(), …). Да и сами арифметические операции, на самом деле, это тоже функции:

'+'(7, 3)
## [1] 10
К функциям, как я говорил, мы ещё вернемся, а пока двинемся дальше.

Но перед этим ещё одна важная деталь. Вы, наверняка, заметили, что после команд я часто пишу # и далее текст. Это комментарии. Они крайне важны в коде, поэтому я, и не только я, настоятельно советую вам их оставлять — и чем больше, тем лучше. Сейчас это может казаться бессмысленным, но поверьте, когда ваш код будет занимать 50+ строк — а это очень небольшой код — разобраться уже будет непросто, не говоря о том, что делать, если вы открыли его через месяц или, не дай боже, год…


Source


Закомментить несколько строк сразу можно сочетанием Ctrl + Shift + C (Cmd + Shift + C).

Сравнение и логические операции
Как мы знаем, числа можно сравнивать. Также мы знаем, что существуют операторы сравнения — все они есть и в R: >, <, >=, <=, ==, != — больше, меньше, больше или равно, меньше или равно, равно (ли), не равно.

Обратите внимание, что сравнение на равенство осуществляется с помощью оператора ==! Одинарное «равно» (=) имеет другой смысл (см. ниже).

Посмотрим на ряд простых примеров:

2 > 4
## [1] FALSE
2 < 6
## [1] TRUE
3 == 5 - 2
## [1] TRUE
7 >= 7
## [1] TRUE
4 != 8 ^ 2
## [1] TRUE
Вроде все логично и понятно. Единственное, что стоит помнить, это то, что приоритет операторов сравнения ниже, чем у арифметических операций.

Само по себе сравнение интуитивно понятно, однако нам интересен здесь получаемый результат. Ранее мы имели дело с числами — здесь что-то другое. С одно стороны, программы выдает на слово, но это не простое слово. Это особый тип данных — логическое значение («истина» TRUE или «ложь» FALSE). Типы данных мы обсудим далее, пока же снова ограничимся простым и интуитивным пониманием.

Мы можем составлять из простых сравнений сложные высказывания с помощью логических операторов. Самые известные и часто используемые из них — «И» (&) и «ИЛИ» (|). Подробно об их смысле здесь. Если в двух словах, то «И» истинно, когда оба соединяемых им утверждений истинны, а «ИЛИ» истинно, когда хотя бы одно из соединяемых им утвердений истинно. Например,

2 > 6 & 8 < 12
## [1] FALSE
1 != 4 & 5 == 10 / 2
## [1] TRUE
6 + 2 < 10 | 8 == 10 # что по сути эквивалентно 8 <= 10
## [1] TRUE
1 + 1 == 2 | FALSE & 4 != 2 * 2
## [1] TRUE
(1 + 1 == 2 | FALSE) & 4 != 2 * 2
## [1] FALSE
Как видно из примеров, приоритет логических операторов ниже приоритета операторов сравнения, а приоритет у & выше, чем у |.

Assignment и переменные
Мы что-то считаем в R и нам важно не терять результаты вычислений. Для этого существуют переменные, в которые можно записывать промежуточные результаты. Делается это так:

x <- 3
В данном случае мы записали в переменную x значение 3
. Разберёмся подробно:

Обозначаем название переменной, в данном случае x. На самом деле, название может быть любое, однако рекомендуется давать им осмысленные имена, чтобы потом не запутаться. Длинные названия — это, скорее, хорошо. Это немного съедает времени сейчас, но значительно экономит его в будущем! Также НЕ рекомендуется использовать для обозначения переменных названия функций (например, data(), str() и др).
Говорим, что надо записать в переменную значение или же присвоить какой-то результат функции. Делается это с помощью оператора присваивания (assignment) <-, который вводится с клавиатуры шорткатом Alt + - (Option + -). Этот оператор записывает то, что справа в то, что слева.
Пишем то, что нужно присвоить в переменную. Это может быть конкретное значение, но чаще это результат какой-либо функции, например:
y <- sin(90)
После создания переменной, она появляется в Environment. Далее переменные можно использовать в вычислениях:

x + y
## [1] 3.893997
x^y * x^2
## [1] 24.03186
log(y, x)
## [1] -0.1019953
x == y
## [1] FALSE
Обратите внимание ещё раз, что сравнивания переменные мы используем оператор ==. А что будет если использовать одно «равно»?

x = y
x
## [1] 0.8939967
Выполнилась операция присваивания. Да, её можно записывать и через «равно», но это не очень принято. Традиционно <- используют для присваивания, а = для задания аргументов функций. У оператора присваивания самый низкий приоритет из всех, то есть присваивание выполняется после всех вычислений. Хм, как неожиданно и логично.

Рабочая директория. Projects
В ходе нализа данных мы работаем со множеством файлов: скрипты, файлы сырых данных данных, файлы предобработанны данных, файл объектов из рабочего пространства, графики, результаты анализа… Это всё куда-то надо сохранять — вопрос куда?

В R есть понятие рабочей директории. Директория — это синоним папки. Рабочая директория — это папка, в которую смотрит R во время работы. Что это за папка можно узнать через команду:

getwd() # get working directory
## [1] "/Users/antonangelgardt/Downloads/Telegram Desktop/hse_rs_appandan_2023"
У меня он смотрел вот в эту папку, у вас, скорее всего, будет что-то типа C://users/имя_пользователя или /Users/имя_пользователя, что указывает на папку пользователя по умолчанию.

Можно установить другую рабочую директорию с помощью команды setwd():

setwd("/Users/antonangelgardt/R") # set working directory
Теперь он будет смотреть в папку R, которая лежит в дефолтной папке пользователя. Такой способ достаточно удобен, однако можно сделать ещё лучше — создать проект (Project).

Projects
Кто-то любит работать в проектах, кто-то нет — дело вкуса. Мне это нравится, даже если вам не понравится. Простите, если мы вдруг не сойдёмся во вкусах, но, повторюсь, это нравится мне, сугубо, лично… Поэтому я буду про это рассказывать и рекламировать.

Зайдите в File → New Project…. У вас откроется такое окно:


Выберите New Directory, затем еще раз New Project:


Откроется вот это:


В Directory name указываем название нашей папки, во втором поле указываем путь к той папке, в которой будет лежать создаваемая папка. Нажимаем Create Project, после чего R перезапускает сессию, и открывается привычное окно. Однако в верхнем правом углу R теперь указано название проекта, в котором мы работаем.

Много ли это приносит профита? Ну, не так уж и много… По сути, что открыть проект, что выполнить setwd("пусть_к_папке") — примерно одно и то же. Вот только строку кода можно забыть запустить после открытия скрипта, а если мы запустили проект, мы уверены, что у нас все автоматически настроилось и ошибок не будет.

Типы данных
Итак, до какого-то момента мы работали только с числами, а затем начали их сравнивать, и получили что-то новое типа TRUE и FALSE. И как мы отметили, это новый тип данных.

А что такое вообще тип данных? Тип данных — это характеристика данных, которая определяет:

множество допустимых значений, которые могут принимать данные этого типа,
и набор операций, которые можно осуществлять с данными этого типа.
Что это значит, будем разбираться на конкретных примерах.

numeric
Этот тип данных нам уже знаком — это числа. Например, если мы создадим переменную со значением 7 и захотим узнать её тип, то это будет выглядеть так:

a <- 7
class(a) # эта команда выводит тип данных
## [1] "numeric"
Итак, действительно, 7
 — это число, нас не обманули.

Вообще-то, в R много типов числовых данных: integer (целые числа), double (числа с десятичной дробной частью), complex (комплексные числа). Последние вам вряд ли встретятся в ближайшее время, а по поводу деления первых можно особо не заморачиваться — R сам разберется, что к чему, и переконвертирует как надо.

Однако для интересующихся есть спойлер — все дело в том, как храняться числа] на железе. А о комплексных числах в R немного можно почитать тут.

Если мы всё же хотим выяснить, что это за числовые данные, то воспользуется функцией typeof():

typeof(a)
## [1] "double"
На числовых данных выполняются все математические операции и различные функции, с чем мы развлекались на протяжении предыдущей главы. А множество значений этого типа, как вы понимаете, бесконечно.

logical
Здесь все гораздо проще. Есть всего два значение TRUE и FALSE, то есть «истина» и «ложь». Получаются логические данные в результате сравнения — и мы это уже тоже видели в предыдущей главе — и на себе сравнение они также допускают.

TRUE == TRUE # но вообще-то это операция, которая не несет никакого смысла
## [1] TRUE
FALSE != FALSE # эта тоже не несет
## [1] FALSE
FALSE == TRUE # и эта
## [1] FALSE
TRUE и FALSE — это логические константы, и, обратите внимание, записываются они прописными буквами. true и True не сработают. Правда есть вариант записывать их только одной буквой T и F, но c’est mauvais ton, и вот почему:

T == TRUE
## [1] TRUE
T <- FALSE
T == TRUE
## [1] FALSE
Константы TRUE и FALSE защищены от перезаписи (на то они и константы).

Поэтому мы не будем жалеть времени и символы и в угоду удобочитаемости и стабильности кода будем писать логические константы полностью.

Кроме сравнения, логический тип данных допускается на себе логические операции, что в общем-то логично.

Основных операций две:

логическое И (конъюнкция, &, ∧
, ⋅
)
логическое ИЛИ (дизъюнкция, |, ∨
, +
)
Работают они следующим образом в соответствии с таблицей истинности:

TRUE & TRUE
## [1] TRUE
TRUE & FALSE
## [1] FALSE
FALSE & TRUE
## [1] FALSE
FALSE & FALSE
## [1] FALSE
TRUE | TRUE
## [1] TRUE
TRUE | FALSE
## [1] TRUE
FALSE | TRUE
## [1] TRUE
FALSE | FALSE
## [1] FALSE
Можем создать и более сложные конструкции. Например, с участие переменных:

x <- 2
y <- 6
n <- 7

x > 2 & y < 10
## [1] FALSE
x != 100 | n != 7
## [1] TRUE
!(x != 100 | n != 7)
## [1] FALSE
Заметьте, что ! существует не только в составе !=, но и как самостоятельный логический оператор и обозначает логическое отрицание.

Также есть оператор xor() (который выглядит как функция5), обозначающий исключающее ИЛИ. Это логическая функция от двух переменных и работает вот так:

xor(TRUE, TRUE)
## [1] FALSE
xor(TRUE, FALSE)
## [1] TRUE
xor(FALSE, TRUE)
## [1] TRUE
xor(FALSE, FALSE)
## [1] FALSE
Он используется редко, но может когда-нибудь внезапно пригодиться.

character
Очевидно, что в практике мы не всегда имеет дело только с цифрами, мы храним ещё и текстовую информацию. Для этого есть тип данных character (хотя другие языки программирования с R бы поспорили).

x <- "Доброе утро, девочки!"
class(x)
## [1] "character"
character — это строки (strings) символов, поэтому они должны быть закавычены одинарными (') или двойными (") кавычками. Так R поймёт, где строка начинается и где заканчивается. Большой разницы между одинарными и двойными кавычками нет, но если у вас кавычки внутри кавычек, здесь надо быть аккуратным:

x <- 'Мужчина громко зашёл в комнату и высказал решительное "здравствуйте"'
x
## [1] "Мужчина громко зашёл в комнату и высказал решительное \"здравствуйте\""
А вообще, есть беспроигрышный [и типографически верный] вариант:

x <- 'Мужчина громко зашёл в комнату и высказал решительное «здравствуйте»'
x
## [1] "Мужчина громко зашёл в комнату и высказал решительное «здравствуйте»"
Строковый тип данных мы еще подробно обсудим в теме работы со строками, а пока посмотрим вот на что…

Конечно, чтобы разговор и типах данных был полным, необходимо сказать о таком типе данных как factor. Хотя он не является «базовым» типом, Всё же ему необходимо уделить некоторое внимание.

factor
Фактор — это строковые данные, которые хранятся как числа. Почему там делать удобно? Потому что фактор содержит определённый (как правило, небольшой) набор уникальных значений (чаще всего около 2–5).

Для чего используются факторы? Для задания каких-либо групп в данных. Например, у вас есть экспериментальные данные, в которых есть два экспериментальных условия и одно контрольное. Тогда вектор, задающий эти условия может выглядет примерно так:

conditions <- c('exp1', 'exp2', 'control', 'exp1', 'exp1', 'exp2', 'control', 'exp2', 'control')
conditions
## [1] "exp1"    "exp2"    "control" "exp1"    "exp1"    "exp2"    "control"
## [8] "exp2"    "control"
Сейчас это строковый вектор — это достаточно просто превратить в фактор:

as.factor(conditions)
## [1] exp1    exp2    control exp1    exp1    exp2    control exp2    control
## Levels: control exp1 exp2
В аутпуте добавилась строчка Levels, которая как раз и определяет набор уникальных значений. По умолчанию уровни фактора выстраиваются в алфавитном (лексикографическом) порядке. Если вам принципиален порядок факторов — например, в случае эксперимента на зрительный поиск у вас есть несколько visual set size (количество стимулов в пробе) — тогда можно воспользоваться специальной функцией и создать упорядоченный фактор:

vis_set_size <- factor(rep(c(3, 6, 9), times = 10),
                       levels = c(3, 6, 9), # задаём порядок уровней
                       ordered = TRUE) # указываем, что нам нужн упорядоченный вектор
vis_set_size
##  [1] 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9 3 6 9
## Levels: 3 < 6 < 9
Теперь в строке Levels указаны не только сами уровни, но и отношение порядка для множестве значений. Как видите, в фактор можно превратить не только текстовый вектор, но и числовой.

В актуальных версиях R обычно текстовые векторы автоматически приводятся к факторам в тех случаях, когда это нужно. Однако если нам нужен числовой вектор как факторный, это придется делать вручную. Хотя, конечно, числовые данные мы чаще всего рассмтариваем именно как числовые.

Coercion [part one]
А что будет, если мы пренебрежём допустимыми операциями и попробуем, например, сложить не-числа? Допустим, так:

TRUE + TRUE # складываем две истины
## [1] 2
Внезапно, команда выполнилась. Можно задаться вопросом, почему именно так, ведь правила алгебры логики говорят, что должно быть по-другому. Опуская детали, скажем, что оператор + несет только арифметический, но не логический смысл, поэтому произошло следующее:

оператор + умеет работать только с числовыми значениями
но получил логические
поэтому попробовал привести их к числовым
у него получилось — TRUE легко и непринуждено приводится к 1, а FALSE к 0
далее выполнилось сложение
Такое поведение называется приведение типов (coercion). Подробно мы его будем обсуждать позже, когда изучим структуры данных и поймем, какие опасности это может за собой влечь. Сейчас же ознакомимся с некоторыми примерами.

Приведение типов сработает не всегда. Например, если мы попытаемся сложить строки6, то получим ошибку:

"abc" + "cbd"
## Error in "abc" + "cbd": non-numeric argument to binary operator
Чтобы контролировать приведение типов, есть семейство функций as.*(). Посмотрим, как они работают.

# приводим логические данные в числовым
as.numeric(TRUE)
## [1] 1
as.numeric(FALSE)
## [1] 0
# приводим числовые данные к логическим
as.logical(1)
## [1] TRUE
as.logical(0)
## [1] FALSE
as.logical(-1) ## наблюдаем, что все не так однозначно
## [1] TRUE
as.logical(0.4)
## [1] TRUE
as.logical(sqrt(2))
## [1] TRUE
# числовые данные к строке
as.character(23)
## [1] "23"
as.character(-150)
## [1] "-150"
# логические данные к строке
as.character(TRUE)
## [1] "TRUE"
as.character(FALSE)
## [1] "FALSE"
Поздравляю! Мы закончили с основами основ! Пора переходить к самому важному и интересному — структурам данных, а именно – векторам!

Структуры данных
С тем, какие существуют данные, мы разобрались. Теперь надо понять, как мы их можем организовать.

Векторы
Простейший способ организации данных — это вектор. Казалось бы, мы знаем, что вектор — это направленный отрезок. Безусловно, это так — в рамках Евклидовой геометрии, которую мы в давнем прошлом учили. Однако это не единственный способ смотреть на вещи. С точки зрения структур данных, вектор — это одномерный массив, а если по-русски, то набор элементов одного типа (например, чисел).

Эти два представления, на самом деле, не противоречат друг другу. Геометрически, как мы сказали, вектор — это направленный отрезок. Он задаётся через координаты начала и конца. Если мы условимся всегда начинать вектор из начала координат — то есть будет считать равными все векторы, которые имеют одинаковую длину и одинаковое направление7 — то мы сможем задавать вектор только через координаты его конца. В случае двумерного пространства вектор будет однозначно задаваться парой чисел (𝑥,𝑦)
, в случае трёхмерного — тройкой чисел (𝑥,𝑦,𝑧)
, а в случае 𝑛
-мерного пространства — набором чисел (𝑥1,𝑥2,𝑥3,…,𝑥𝑛)
.

Чтобы создать вектор в R надо воспользоваться функцией c(). Она принимает неограниченное количесво аргументов, которые объединяет в вектор. В вектор можно объединить элементы только одного типа.

v <- c(1,2,3,5,6,7)
Сохраним получившийся числовой вектор в переменную v. Присваивание векторов ничем не отличается от присваивания чисел, во-первых, потому что в R нет скаляров, и все числа — это векторы типа numeric длиной 1, а во-вторых, потому что и число, и вектор, и другие структуры данных (и даже функции!) — всё это объекты. А assignment — не что иное, как присваивание имени некоторому объекту, и нет разницы, что мы называем — число, матрицу, список, датафрейм или функцию.

Coercion [part two]
Взбунтуемся, и объеденим в один вектор разные типы данных:

v0 <- c(1, 2, TRUE, FALSE)
v0
## [1] 1 2 1 0
Бунт не удался — вектор всё равно был создан. Но что произошло?


С приведением типов мы уже сталкивались, когда пытались складывать логические константы. Аналогично R действовал и здесь:

есть задача создать вектор
но на выход функции поступили данные различных типов
придётся сделать так, чтобы тип был всё-таки один
numeric к logical однозначно привести сложно (что есть 2 — TRUE или FALSE?)
logical к numeric приводится очень хорошо и красиво (TRUE — 1, FALSE — 0)
после приведения типов можно выполнить команду создания вектора.
Сделаем вектор из полного салата — добавим сторовые значения:

v0 <- c(1, 2, TRUE, FALSE, 'text', 'string')
v0
## [1] "1"      "2"      "TRUE"   "FALSE"  "text"   "string"
Наблюдаем, что все свелось к типу character, что вполне ожидаемо, так как 2 в "2" превращается однозначно, а вот в какое число (или логическую константу) превратить "string", не очень понятно.

Собственно, можно вывести иерархию приведения типов:

logical < integer < numeric < complex < character
Генерация числовых последовательностей
Создавать руками векторы — это, конечно, радостно и приятно, но не очень юзабельно. На практике часто возникает потребность сгенерировать определенную числовую последовательность. Например, у вас есть опросниковые данные, из которых необходимо удалить персональные данные, но при этом сохранить возможность соотнести персональные данные и результаты анализа по каждому респонденту — вам нужно сгенерировать переменную ID. Вам поможет оператор :, который генерирует последовательность в заданных пределах с шагом 1:

1:10
##  [1]  1  2  3  4  5  6  7  8  9 10
15:0
##  [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
Если вам нужна последовательно с другим шагом, например, 0.5, то подойдет функция seq():

seq(from = 1, to = 10, by = 0.5) # задаём шаг последовательности
##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0
## [16]  8.5  9.0  9.5 10.0
seq(0, -6, -1.5) # или без указания названий аргументов
## [1]  0.0 -1.5 -3.0 -4.5 -6.0
seq(from = 5, to = 30, length.out = 20) # задаём длину последовательности
##  [1]  5.000000  6.315789  7.631579  8.947368 10.263158 11.578947 12.894737
##  [8] 14.210526 15.526316 16.842105 18.157895 19.473684 20.789474 22.105263
## [15] 23.421053 24.736842 26.052632 27.368421 28.684211 30.000000
Допустим, у вас есть данные (пусть выборка будет 15 человек), в которых каждые две строки относятся к одному респонденту, но к двум различным экспериментальным условиям (экспериментальному и контрольному). Тогда можно сделать такие переменные:

rep(1:15, each = 2) # для id
##  [1]  1  1  2  2  3  3  4  4  5  5  6  6  7  7  8  8  9  9 10 10 11 11 12 12 13
## [26] 13 14 14 15 15
rep(c('exp', 'control'), times = 15) # для обозначения условия
##  [1] "exp"     "control" "exp"     "control" "exp"     "control" "exp"    
##  [8] "control" "exp"     "control" "exp"     "control" "exp"     "control"
## [15] "exp"     "control" "exp"     "control" "exp"     "control" "exp"    
## [22] "control" "exp"     "control" "exp"     "control" "exp"     "control"
## [29] "exp"     "control"
Также можно сгенерировать случайную последовательность чисел (например, для того, чтобы использовать её при сабсете случайной подвыборки данных):

sample(x = 1:30, size = 15)
##  [1]  4 13 20 16 25 24 10  1  8 23 17  2 15  5 12
Чтобы результат генерации при повторном запуске кода получался одним и тем же, перед выполнением команды sample(...) нужно выполнить команду set.seed(...):

set.seed(69)
Число внутри функции может быть абсолютно любым.

Операции с векторами
Операции, которые можно выполнять над векторами зависят от типа данных, которые содержатся в векторе. Чаще всего мы будем работать с числовыми векторами, поэтому разберем подробно именно их.

Пусть у нас будет два вектора:

set.seed(42) # задаём положение для датчика случайных чисел
v1 <- sample(1:100, 20)
v2 <- sample(-50:100, 20)
Над векторами можно выполнять арифметические операции:

v1 + v2
##  [1]  56  56  -2  66 110 200 132   9  88 147  78 -27  74  66  -4 110 115  70 -14
## [20] 154
v1 - v2
##  [1]  42  74  52  82 -74   0 -38  39  54  31  -4  67 -22 -60  86 -56 -43 -60  82
## [20]  20
v1 * v2
##  [1]   343  -585  -675  -592  1656 10000  3995  -360  1207  5162  1517  -940
## [13]  1248   189 -1845  2241  2844   325 -1632  5829
v1 / v2
##  [1]  7.00000000 -7.22222222 -0.92592593 -9.25000000  0.19565217  1.00000000
##  [7]  0.55294118 -1.60000000  4.17647059  1.53448276  0.90243902 -0.42553191
## [13]  0.54166667  0.04761905 -0.91111111  0.32530120  0.45569620  0.07692308
## [19] -0.70833333  1.29850746
Они выполняются поэлементно, то есть соответсвующие элементы двух векторов складываются (вычитаются, умножаются, делятся), и в результате получается новый вектор.

Кроме того, векторы можно поэлементно сравнивать:

v1 < v2
##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE
## [13]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE
v1 == v2
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
v2 <= v1
##  [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE
## [13] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE
Также к вектору можно применять и функции:

sin(v1)
##  [1] -0.9537527  0.8268287 -0.1323518 -0.9851463 -0.7509872 -0.5063656
##  [7]  0.1235731 -0.9055784  0.9510547  0.8600694 -0.6435381  0.9129453
## [13]  0.7625585  0.1411200 -0.1586227  0.9563759 -0.9917789 -0.9589243
## [19]  0.5290827 -0.8218178
log(v1)
##  [1] 3.891820 4.174387 3.218876 4.304065 2.890372 4.605170 3.850148 3.178054
##  [9] 4.262680 4.488636 3.610918 2.995732 3.258097 1.098612 3.713572 3.295837
## [17] 3.583519 1.609438 3.526361 4.465908
exp(v2)
##  [1] 1.096633e+03 1.234098e-04 1.879529e-12 3.354626e-04 9.017628e+39
##  [6] 2.688117e+43 8.223013e+36 3.059023e-07 2.415495e+07 1.545539e+25
## [11] 6.398435e+17 3.873998e-21 7.016736e+20 2.293783e+27 2.862519e-20
## [16] 1.112864e+36 2.038281e+34 1.694889e+28 1.425164e-21 1.252363e+29
Можно применять несколько функций подряд:

log(abs(v2))
##  [1] 1.945910 2.197225 3.295837 2.079442 4.521789 4.605170 4.442651 2.708050
##  [9] 2.833213 4.060443 3.713572 3.850148 3.871201 4.143135 3.806662 4.418841
## [17] 4.369448 4.174387 3.871201 4.204693
Большинство арифметических функций выполняется поэлементно, однако существуют такие, которые поэлементно не могут быть выполнены, например сумма по вектору:

sum(v1)
## [1] 878
Или функция, которая вычисляет длину вектора (в смысле количества элементов в нём):

length(v2)
## [1] 20
Recycling
Доныне мы складывали векторы одинаковой длины. С ними всё ясно — они складываются поэлементно. А что будет, если мы сложим векторы разной длины?

v3 <- rep(1, times = 10); v3 # создаём векторы
##  [1] 1 1 1 1 1 1 1 1 1 1
v4 <- sample(1:100, 2); v4
## [1] 21  2
v5 <- sample(1:100, 3); v5
## [1] 58 10 40
length(v3) # проверяем длину
## [1] 10
length(v4)
## [1] 2
length(v5)
## [1] 3
Итак, сумма:

v3 + v4
##  [1] 22  3 22  3 22  3 22  3 22  3
v3 + v5
## Warning in v3 + v5: longer object length is not a multiple of shorter object
## length
##  [1] 59 11 41 59 11 41 59 11 41 59
Внимательно посмотрим на результат. В первом случае мы складывали вектор из десяти элементов и вектор из двух элементов. Чтобы выполнирь эту операцию R выполняет зацикливание (recycling) более короткого из двух, чтобы каждый элемент большего по длине вектора получил в соответствии элементн меньшего. Так как десять кратно двум, то по сути было выполнена следующая команда:

v3 + rep(v4, 
         times = length(v3) / length(v4))
##  [1] 22  3 22  3 22  3 22  3 22  3
Во втором случае длина меньшего вектора не кратна длине большего, поэтому recycling происходит до тех пор, пока не будут покрыты все элемент большего вектора. Вектор из трех элементов укладывается на вектор из десяти элементов три раза — поэтому мы видим в результате три раза последовательность 59, 11, 41 — и остается ещё один десятый элемент, который суммируется в первым элементом меньшего вектора — поэтому последний элемент в векторе результата 59.

Индексация векторов
В практике мы постоянно сталкиваемся в необходимость анализировать не все данные в векторе, а их часть. Поэтому встаёт вопрос о том, как эту часть извлечь?

Извлечение части данных из вектора называется индексацией. Это делается так:

v1[1:10] # первые десять элементов вектора
##  [1]  49  65  25  74  18 100  47  24  71  89
v1[c(1,3,5,7)] # 1-й, 3-й, 5-й и 7-й элементы вектора
## [1] 49 25 18 47
v1[sample(1:20, 5)] # случайная подвыборка пяти элементов
## [1] 18 49 36 47 74
Логика проста — чтобы взять часть вектора, нам нужен вектор индексов тех элементов, которые мы хотим вытащить. Его мы поместим в квадратные скобки — и будет нам счастье. Вектор индектов можно получить любыми способами:

сгенерировать последовательноть (как в первом варианте),
задать индексы вручную, не забыв при этом обернуть их в фнукцию c(), чтобы указать, что это вектор, (как во втором варианте),
воспользоваться функцией, которая возвращает вектор.
Полезно также является индексация через отрицательные индексы:

v2
##  [1]   7  -9 -27  -8  92 100  85 -15  17  58  41 -47  48  63 -45  83  79  65 -48
## [20]  67
v2[-1] # все элементы, кроме первого
##  [1]  -9 -27  -8  92 100  85 -15  17  58  41 -47  48  63 -45  83  79  65 -48  67
v2[-(1:5)] # все элементы, кроме первых пяти
##  [1] 100  85 -15  17  58  41 -47  48  63 -45  83  79  65 -48  67
Особого внимания заслуживает индексация логическими векторами. Например, мы хотим отобрать все элементы вектора, которые больше некоторого числа. Как это сделать?

Нам нужен вектор, которым мы будем индексировать исходный вектор. Как его получить? Известно, что при сравнении векторов между собой получается логический вектор. Но ведь число — это тоже вектор, просто единичной длины? Значит, если мы будем сравнивать вектор с числом, произойдёт recycling, в результате которого каждый элемент вектора будет сравнен с этим числом. То есть:

v1 > 40
##  [1]  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE
## [13] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
Отлично! Вектор есть. Можно ли им проидексировать наш исходный вектор v1? Можно! Аналогично тому, как мы это уже делали.

v1[v1 > 40]
## [1]  49  65  74 100  47  71  89  41  87
Конструкция, возможно, выглядит немного странновато — но работает!

NA, NaN, NULL
Взбунтуемся ещё раз и посмотрим, что получится, если мы будем вытаскивать из вектора элементы, используя индексы, которые выходят за границы длины вектора. Например, у нас есть вектор v2, длина которого

length(v2)
## [1] 20
Попробуем сделать так:

v2[15:25]
##  [1] -45  83  79  65 -48  67  NA  NA  NA  NA  NA
Мы получили нечто, с чем ранее не сталкивались. NA (от not available) обозначает значение, которое недоступно. Как правило, в реальных данных они появляются при каких-либо ошибках записи данных. Впрочем, не всегда. Можно придумать и такой дизайн исследования, когда пропуски также будут информативны и могут анализировться. В нашем случае мы обратились к элементам, которых нет в нашем векторе, поэтому R ничего более не смог сделать, как вернуть нам свидетельство того, что такие элементы он из вектора достать не смог.

NA ведёт себя весьма специфично. Например, если мы попробуем посчитать сумму по получившемуся вектору, то результат будет следующим:

sum(v2[15:25])
## [1] NA
Аналогичная ситуация возникнет, если мы будем вычислять среднее:

mean(v2[15:25])
## [1] NA
Такое поведение функций может поначалу напрягать, однако оказывается очень полезным при работе с реальными данными.

И всё же функция sum() не так проста, и умеет бороться с NA. Для этого у неё есть аргумент na.rm, которому нужно задать значение TRUE, если мы хотим, чтобы сумма все же была посчитана:

sum(v2[15:25], na.rm = TRUE)
## [1] 201
Попробуем вычислить логарифм по вектору v2:

log(v2)
## Warning in log(v2): NaNs produced
##  [1] 1.945910      NaN      NaN      NaN 4.521789 4.605170 4.442651      NaN
##  [9] 2.833213 4.060443 3.713572      NaN 3.871201 4.143135      NaN 4.418841
## [17] 4.369448 4.174387      NaN 4.204693
Опять всё не слава богу. Теперь у нас NaN. Это почти как NA, но не совсем. NaN обозначает не-число (not a number). То есть, это не пропущенное значение, оно существует, но R его не может вычислить. Если мы сравним два вектора,

v2; log(v2)
##  [1]   7  -9 -27  -8  92 100  85 -15  17  58  41 -47  48  63 -45  83  79  65 -48
## [20]  67
## Warning in log(v2): NaNs produced
##  [1] 1.945910      NaN      NaN      NaN 4.521789 4.605170 4.442651      NaN
##  [9] 2.833213 4.060443 3.713572      NaN 3.871201 4.143135      NaN 4.418841
## [17] 4.369448 4.174387      NaN 4.204693
то обнаружим, что NaN появляется там, где мы пытаемся вычислить логарим отрицательного числа. А, как мы помним, функция логарифма определена только на положительно полуоси 𝑥
. Вот и получается, что логарифм отрицательного аргумента — это какая-то неведомая сущность, то точно не-число.

В функциях NaN ведёт себя аналогично NA:

sum(log(v2))
## Warning in log(v2): NaNs produced
## [1] NaN
Мы поговорили о двух важный константах используемых в R. Есть ещё одна, и имя её NULL. Это имя обозначает «ничего», то есть, что объект пуст.

Например, возьмем вектор v, который мы создавали в самом начале, и положим в него NULL:

v <- NULL
v
## NULL
Теперь в этом векторе ничего не лежит.

NULL может использоваться при задании аргументов функций или как результат работы функций, если возвращается пустой объект.

Матрицы
Говоря о векторах, мы обозначили, что вектор — это одномерный массив. А раз есть одномерные массивы, значит бывают какие-то ещё? Да. Сгенерируем некоторый вектор:

v6 <- sample(1:100, 12); v6
##  [1] 73 29 76 84  9 35 93 16 92 69  2 82
и попробуем его «сложить» в «таблицу» так, чтобы в каждой строке было по три числа:

m1 <- matrix(v6, ncol = 3); m1
##      [,1] [,2] [,3]
## [1,]   73    9   92
## [2,]   29   35   69
## [3,]   76   93    2
## [4,]   84   16   82
Так как мы «складываем друг на друга» части одномерного массива, у нашего нового массива возникает новое измерение — если вектор был только одной строкой, то теперь в нашем массиве есть и строки, и столбцы. Двумерный массив назвается матрицей.

class(m1)
## [1] "matrix" "array"
И поэтому для его создания мы использовали функцию matrix(). В качестве основных аргументов она хочет видеть вектор, который мы будет «упаковывать» в матрицу, а также количество строк или столбцов новой матрицы.

Индексация матриц
От того, что мы свернули вектор в матрицу, он не перестал быть вектором. [Шок!] То есть матрица по сути всё ещё тот же самый вектор, поэтому индексировать её можно точно так же, как и вектор:

v6[1]; m1[1]
## [1] 73
## [1] 73
v6[4]; m1[4]
## [1] 84
## [1] 84
v6[11]; m1[11]
## [1] 2
## [1] 2
Однако поскольку матрица — это всё же матрица, она отличается от вектора тем, что у неё есть дополнительный атрибут dim, который отображает её размерность:

dim(m1)
## [1] 4 3
В данном случае наблюдаем, что размерность матрицы 4×3
, и это справедливо, ведь именно такую матрицу мы и создавали. А раз у нас имеется указание на количество строк и столбцов в матрице, то мы можем вытащить элемент(ы) как раз по его позиции:

m1[1, 2] # вытаскиваем элемент из первой строки и второго столбца
## [1] 9
Те же квадратные скобки, только указываем мы теперь две «координаты» — сначала строки, затем столбцы. Как не запутаться? Аналогия с координатами не случайна: строки — горизонтальны, первая координата на координата на координатной плоскости (𝑥
) тоже задаёт положение точки на горизонтальной оси; столбцы — вертикальны, вторая координата (𝑦
) задает положение точки на вертикальной оси.

Также мы можем вытащить не только отдельный элемент, но и какую-то часть матрицы. Всё работает аналогично векторам:

m1[1:3, 2:3]
##      [,1] [,2]
## [1,]    9   92
## [2,]   35   69
## [3,]   93    2
Если мы выползем за границы индексации, R начнёт ругаться:

m1[1:3, 2:4]
## Error in m1[1:3, 2:4]: subscript out of bounds
Операции c матрицами
См. книжку.

Списки
До текущего момента мы говорили о структурах данных, которые требуют одинакового типа данных в себе. Давайте теперь вообразим вектор без ограничения на однотипность данных. Это будет список (list).

l <- list(69, "text", TRUE)
l
## [[1]]
## [1] 69
## 
## [[2]]
## [1] "text"
## 
## [[3]]
## [1] TRUE
Но список даёт нам ещё больше возможностей, потому что он может собирать в себя вообще любые объекты:

l2 <- list(c("This", "list", "contains", "a", "matrix"), m1, l)
l2
## [[1]]
## [1] "This"     "list"     "contains" "a"        "matrix"  
## 
## [[2]]
##      [,1] [,2] [,3]
## [1,]   73    9   92
## [2,]   29   35   69
## [3,]   76   93    2
## [4,]   84   16   82
## 
## [[3]]
## [[3]][[1]]
## [1] 69
## 
## [[3]][[2]]
## [1] "text"
## 
## [[3]][[3]]
## [1] TRUE
Таким образом, список может являть собой крайне сложную структуру. Чтобы разобраться, как устроен конкретный список, можно воспользоваться функцией str(), которая отобразит структуру списка:

str(l2)
## List of 3
##  $ : chr [1:5] "This" "list" "contains" "a" ...
##  $ : int [1:4, 1:3] 73 29 76 84 9 35 93 16 92 69 ...
##  $ :List of 3
##   ..$ : num 69
##   ..$ : chr "text"
##   ..$ : logi TRUE
Как видно в аутпуте функции, список содержит три элемента: текстовый вектор длиной 5, массив целых чисел, размером 4×3, и список, который в свою очерель состоит также из трёх элементов — числа 69, строкового вектора, содержащего одно значение (“text”) и логического вектора длиной 1, который содержит значение «истина».

Можно назвать отдельные элементы списка собственными именами:

# создадим список такой же, как l2, только именованный
l3 <- list(description = c("This", "list", "contains", "a", "matrix"),
           matrix = m1,
           inner_list = l)
l3
## $description
## [1] "This"     "list"     "contains" "a"        "matrix"  
## 
## $matrix
##      [,1] [,2] [,3]
## [1,]   73    9   92
## [2,]   29   35   69
## [3,]   76   93    2
## [4,]   84   16   82
## 
## $inner_list
## $inner_list[[1]]
## [1] 69
## 
## $inner_list[[2]]
## [1] "text"
## 
## $inner_list[[3]]
## [1] TRUE
Индексация списков
Списки в R появляются достаточно часто — и, главным образом, как результат работы функций. Собственными руками мы их создавать вряд ли когда либо будем, а вот вытаскивать из них инфу по частям нам научиться надо обязательно.

Поскольку список как и вектор состоит из отдельных элементов, которые в нём расположены в определённом порядке, то можно поступить со списком как с вектором:

l3[1]
## $description
## [1] "This"     "list"     "contains" "a"        "matrix"
Мы помним, что с списке l3 первым элементом был строковый вектор. Однако когда мы обратились к первому элементу, нам вернулся список, содержащий этот вектор. Да, такова особенность индексации списков — если мы используем одинарные квадратные скобки, то возвращается список из одного элемента. Почему так? Потому что если мы заходим вытащить, например, первые два элемента, то они могут оказаться различной структуры, и вернуть их вместе, кроме как списком, нет варианта.

l3[1:2]
## $description
## [1] "This"     "list"     "contains" "a"        "matrix"  
## 
## $matrix
##      [,1] [,2] [,3]
## [1,]   73    9   92
## [2,]   29   35   69
## [3,]   76   93    2
## [4,]   84   16   82
Чтобы вытащить сам вектор, нам потребуются двойные квадратные скобки:

l3[[1]]
## [1] "This"     "list"     "contains" "a"        "matrix"
Можно пойти далее и вытащить какой-то элемент из вектора прямо в этой же строке:

l3[[1]][c(1, 5)] # вытащим сразу первый и пятый
## [1] "This"   "matrix"
Раз у нас именованный список, то можно вытащить элемент по имени (с векторами тоже работает):

l3['matrix'] # так вернётся список
## $matrix
##      [,1] [,2] [,3]
## [1,]   73    9   92
## [2,]   29   35   69
## [3,]   76   93    2
## [4,]   84   16   82
l3[['matrix']] # а так сама матрица
##      [,1] [,2] [,3]
## [1,]   73    9   92
## [2,]   29   35   69
## [3,]   76   93    2
## [4,]   84   16   82
Но списки нам предоставляют ещё одну удобную и полезную фичу — индексацию по имени, но другим способом:

l3$description
## [1] "This"     "list"     "contains" "a"        "matrix"
l3$matrix
##      [,1] [,2] [,3]
## [1,]   73    9   92
## [2,]   29   35   69
## [3,]   76   93    2
## [4,]   84   16   82
Обратите внимание, что в таком случае сразу возвращается «голый» объект — вектор, матрица, etc. Запомните этот способ — так мы будем делать о-о-очень часто (примерно всегда).

Датафреймы
Ура! Мы добрались до самого интересноо в самого важного!

Кратко вспомним, что мы умеем к этому моменту:

манипулировать с векторами (создавать, индексировать, производить разные математические операции)
работать с матрицами (создавать, индексировать, производить разные математические операции)
обращаться со списками (создавать и индексировать различными способами)
Так вот все эти знания и умения нам нужны, чтобы мастерски жонглировать датафреймами. Датафрейм — это детище большой любви матрицы и списка:

В одном из домашних заданий вы создавали матрицу, которая содержала имена респондентов, их пол, город проживания и любимый цвет. Но ождиаемое ограничение было в том, что все данные неизбежно приводились к строковому типу. И в таком варианте вроде бы ничего криминального, но если мы захотим добавить данные о возраста — что делать? Хорошо мы, чтобы они сохранились в числовом формате, ведь так с ними дальше будет удобно работать.

# немного изменим набор переменных для демонстрации возможностей
df <- data.frame(name = c('Илья', 'Алёна', 'Виктор', 'Елена', 'Кристина'),
                 age = c(21, 34, 19, 52, 26),
                 sex = c('муж', 'жен', 'муж', 'жен', 'жен'),
                 city = c("Орёл", "Тверь", "Тирасполь", "Питер", "Москва"))
df
##       name age sex      city
## 1     Илья  21 муж      Орёл
## 2    Алёна  34 жен     Тверь
## 3   Виктор  19 муж Тирасполь
## 4    Елена  52 жен     Питер
## 5 Кристина  26 жен    Москва
Обратите внимание, датафрейм создается практически так же, как и список, только функция другая. А в итоге получается привычная нам таблица! Magique!

Как устроена эта таблица? По сути датафрейм — это именованный список, каждый элемент которого — это вектор определённой длины (одинаковой для всех векторов, входящих в этот список). Так они одинаковой длины, то их можно «поставить рядом друг с другом» как колонки матрицы. Собственно, так и получается. Вот только в данному случае разные столбцы могут содержать разный тип данных.

И тем не менее, поскольку датафрейм наследует свойства обоих своих «родителей», обращаться с ним можно и как со списком, и как с матрицей:

str(df) # изучаем структуру
## 'data.frame':    5 obs. of  4 variables:
##  $ name: chr  "Илья" "Алёна" "Виктор" "Елена" ...
##  $ age : num  21 34 19 52 26
##  $ sex : chr  "муж" "жен" "муж" "жен" ...
##  $ city: chr  "Орёл" "Тверь" "Тирасполь" "Питер" ...
df$name # вытаскиваем элемент списка (вектор имён респондентов)
## [1] "Илья"     "Алёна"    "Виктор"   "Елена"    "Кристина"
df$name[1:3] # индексируем вектор имён респондентов
## [1] "Илья"   "Алёна"  "Виктор"
df[, 1] # так тоже срабоает
## [1] "Илья"     "Алёна"    "Виктор"   "Елена"    "Кристина"
df[1] # и даже так, но какая структура данных вернулась?
##       name
## 1     Илья
## 2    Алёна
## 3   Виктор
## 4    Елена
## 5 Кристина
df[1:2, 3:4] # ну это просто пушка
##   sex  city
## 1 муж  Орёл
## 2 жен Тверь
Можно добавить новые переменные:

df$married <- FALSE # recycling has happened
Функции
См. книжку.

Открытый исходный код
В R можно не только написать свои функции, но и посмотреть, как написаны другие, то есть увидеть исходный код. Для этого надо написать название функции и выполнить её как команду (без скобок):

sd # стандартное отклонение --- корень из дисперсии
## function (x, na.rm = FALSE) 
## sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), 
##     na.rm = na.rm))
## <bytecode: 0x7fb7fa7d1870>
## <environment: namespace:stats>
lm # функция для построения линейной регрессионной модели
## function (formula, data, subset, weights, na.action, method = "qr", 
##     model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
##     contrasts = NULL, offset, ...) 
## {
##     ret.x <- x
##     ret.y <- y
##     cl <- match.call()
##     mf <- match.call(expand.dots = FALSE)
##     m <- match(c("formula", "data", "subset", "weights", "na.action", 
##         "offset"), names(mf), 0L)
##     mf <- mf[c(1L, m)]
##     mf$drop.unused.levels <- TRUE
##     mf[[1L]] <- quote(stats::model.frame)
##     mf <- eval(mf, parent.frame())
##     if (method == "model.frame") 
##         return(mf)
##     else if (method != "qr") 
##         warning(gettextf("method = '%s' is not supported. Using 'qr'", 
##             method), domain = NA)
##     mt <- attr(mf, "terms")
##     y <- model.response(mf, "numeric")
##     w <- as.vector(model.weights(mf))
##     if (!is.null(w) && !is.numeric(w)) 
##         stop("'weights' must be a numeric vector")
##     offset <- model.offset(mf)
##     mlm <- is.matrix(y)
##     ny <- if (mlm) 
##         nrow(y)
##     else length(y)
##     if (!is.null(offset)) {
##         if (!mlm) 
##             offset <- as.vector(offset)
##         if (NROW(offset) != ny) 
##             stop(gettextf("number of offsets is %d, should equal %d (number of observations)", 
##                 NROW(offset), ny), domain = NA)
##     }
##     if (is.empty.model(mt)) {
##         x <- NULL
##         z <- list(coefficients = if (mlm) matrix(NA_real_, 0, 
##             ncol(y)) else numeric(), residuals = y, fitted.values = 0 * 
##             y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w != 
##             0) else ny)
##         if (!is.null(offset)) {
##             z$fitted.values <- offset
##             z$residuals <- y - offset
##         }
##     }
##     else {
##         x <- model.matrix(mt, mf, contrasts)
##         z <- if (is.null(w)) 
##             lm.fit(x, y, offset = offset, singular.ok = singular.ok, 
##                 ...)
##         else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, 
##             ...)
##     }
##     class(z) <- c(if (mlm) "mlm", "lm")
##     z$na.action <- attr(mf, "na.action")
##     z$offset <- offset
##     z$contrasts <- attr(x, "contrasts")
##     z$xlevels <- .getXlevels(mt, mf)
##     z$call <- cl
##     z$terms <- mt
##     if (model) 
##         z$model <- mf
##     if (ret.x) 
##         z$x <- x
##     if (ret.y) 
##         z$y <- y
##     if (!qr) 
##         z$qr <- NULL
##     z
## }
## <bytecode: 0x7fb7f6c95f80>
## <environment: namespace:stats>
Строки
Мы уже знакомились со строковым типом данных character. Но мы обозначили, что многие операции над этим типом невозможны (например, нельзя сложить две строки). Возникает вопрос: что делать?

Для начала научимся ставить дополнительные пакеты.

Установка дополнительных пакетов
В самом начале мы упоминали, что R имеет большие возможности расширения функционала с помощью специальных пакетов. Для работы со строками нам будут нужны два — stringi («стринг-ай») и stringr («стринг-ар»). На их примере мы и разберем механизм установки и подключения дополнительных пакетов.

Пакет — это набор функций, не входящих в «базовую комплектацию R», которые, как правило, специализированы под те или иные задачи. В нашем случае — под работу со строками. Поэтому сначала пакет необходимо скачать на комп:

install.packages(c("stringi", "stringr"))
В функцию install.packages() необходимо передать строковый вектор, содержащий названия пакетов, которые мы бы хотели установить.

Часто одни пакеты ссылаются на функции других, поэтому можно указать в аргументе dependencies TRUE, чтобы попутно установились зависимые пакеты.

install.packages(c("stringi", "stringr"), dependencies = TRUE)
По умолчанию пакеты скачиваются с репозитория CRAN — основное хранилище, где лежит подавляющее большинство пакетов и всякого разного. Но может быть такое, что установить соединение с этим репозиторием по каким-либо причинам не получается. Чтобы пофиксить сей баг, нужно указать в настройках какое-либо из зеркал. Options → Packages → Primary CRAN repository → Change…, и выбрать что-то. Если не помогло — попробуйте ещё.

Но мало просто скачать пакет. Надо его ещё подключить к текущей сессии, в которой мы работаем. Для этого используется функция

library(stringi)
library(stringr)
Ей уже надо скормить название пакета без кавычек, и для подключения каждого пакета потребуется написать новую строчку.

Тут запутываются термины «пакет» и «библиотека», но опустим эти детали и примем сей момент как есть…

После того, как мы подключили пакет к данной сессии, мы можем использовать функции из него.

Кайф, поехали!

Создание строк
Можно сделать строку руками (наблюдайте за кавычками):

s1 <- "сложившаяся структура организации влечет за собой процесс внедрения и модернизации новых предложений"
s1
## [1] "сложившаяся структура организации влечет за собой процесс внедрения и модернизации новых предложений"
s2 <- 'С другой стороны постоянный количественный "рост" и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации'
s2
## [1] "С другой стороны постоянный количественный \"рост\" и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации"
s3 <- "С другой стороны постоянный количественный "рост" и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации"
s3
## Error: <text>:1:52: unexpected symbol
## 1: s3 <- "С другой стороны постоянный количественный "рост
##                                                        ^
s4 <- "С другой стороны постоянный количественный 'рост' и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации"
s4
## [1] "С другой стороны постоянный количественный 'рост' и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации"
s5 <- "С другой стороны постоянный количественный «рост» и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации"
s5
## [1] "С другой стороны постоянный количественный «рост» и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации"
s6 <- "" # это пустая строка
s6
## [1] ""
Также можно использовать функцию character()8 для создания вектора из пустых строк:

character(5)
## [1] "" "" "" "" ""
А также функции для приведения типов, которые мы уже обсуждали:

as.character(1:30)
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15"
## [16] "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" "30"
Кроме того, существуют встроенные текстовые векторы:

letters
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
LETTERS
##  [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
## [20] "T" "U" "V" "W" "X" "Y" "Z"
Есть ещё встроенные векторы, которые содержат названия месяцев и аббревиатуры названий месяцев. Можете их отыскать.

Мы умеем генерировать числавые последовательности. Можно также генерировать и строки. Например, когда вы хотите сгенерировать ID для испытуемых не просто как числа, а как уникальные текстовые значения:

stri_rand_strings(n = 10, length = 5)
##  [1] "DDOwx" "jjX0b" "pkSXX" "0MbpM" "PZaiO" "uxEiu" "bdwqZ" "o7lc9" "4Smjo"
## [10] "AwI9i"
Фнукции из пакета stringi начинаются с префикса stri, а функции пакета stringr — с префикса str. Их легко можно опознать.

Конкатенация строк
Строки можно соединять воедино:

paste('first', 'second', 'third') # базовый R
## [1] "first second third"
paste('first', 'second', 'third', sep = "_")
## [1] "first_second_third"
paste0('first', 'second', 'third')
## [1] "firstsecondthird"
stri_c('first', 'second', 'third') # пакет stringi
## [1] "firstsecondthird"
stri_c('first', 'second', 'third', sep = " & ") # пакет stringi
## [1] "first & second & third"
Разделение строк
Если добрый коллега записал экспериментальные условия в одну переменную как выше, а вам нужно делать по ним, например, какую-нибудь анову, то можно на него долго ругаться, а можно разделить строки обратно:

s_exp <- paste('first', 'second', 'third', sep = "_")
s_exp
## [1] "first_second_third"
str_split(s_exp, pattern = "_")
## [[1]]
## [1] "first"  "second" "third"
Нам вернулся список. Шо с ним делать — вопрос хороший. Можно развернуть список в вектор и индексацией вытащить нужные нам части.

Но есть более удобная функция separate(), которая разбивает субстроки сразу по колонкам. Её мы вспомним, когда будет говорить о предобработке данных.

Сортировка строк
Строки можно сортировать:

unsorted_s <- paste0(
  sample(LETTERS, size = length(LETTERS), replace = TRUE),
  sample(letters, size = length(letters)),
  sample(letters, size = length(letters))
) # делаем несортированный вектор из трёхбуквенных «слов»
unsorted_s
##  [1] "Xbz" "Aja" "Ywe" "Ylc" "Siv" "Qam" "Nzk" "Ntq" "Okd" "Fnt" "Xsy" "Oxi"
## [13] "Kpp" "Eru" "Pyl" "Qvn" "Vfr" "Qes" "Rqo" "Buh" "Fgj" "Vmb" "Fcw" "Fhf"
## [25] "Tdx" "Oog"
Сортируем:

sort(unsorted_s) # можно базовой функцией
##  [1] "Aja" "Buh" "Eru" "Fcw" "Fgj" "Fhf" "Fnt" "Kpp" "Ntq" "Nzk" "Okd" "Oog"
## [13] "Oxi" "Pyl" "Qam" "Qes" "Qvn" "Rqo" "Siv" "Tdx" "Vfr" "Vmb" "Xbz" "Xsy"
## [25] "Ylc" "Ywe"
str_sort(unsorted_s) # можно функцией из пакета stringr
##  [1] "Aja" "Buh" "Eru" "Fcw" "Fgj" "Fhf" "Fnt" "Kpp" "Ntq" "Nzk" "Okd" "Oog"
## [13] "Oxi" "Pyl" "Qam" "Qes" "Qvn" "Rqo" "Siv" "Tdx" "Vfr" "Vmb" "Xbz" "Xsy"
## [25] "Ylc" "Ywe"
Строки сортируются в лексикографическом порядке. Обратите внимание, что порядок сортировки зависит от того, в какой локали мы работаем, то есть от того, алфавит какого языка используется для определения лексикографического порядка:

str_sort(c("э", "а", "у", "i"), locale = 'en') # по умолчанию
## [1] "i" "а" "у" "э"
str_sort(c("э", "а", "у", "i"), locale = 'ru') # русский
## [1] "а" "у" "э" "i"
Сортировок существует много разных. Но чем больше у вас данные, тем медленнее будет работать базовый sort(). Поэтому используйте str_sort().

Изменение регистра
Допусти вы собирали данные онлайн, и у вас было поле ступень образования, в которой респонденты должны быть указать бакалавриат/магистратура/аспирантура. Но по каким-то причинам, разработчик онлайн-формы не подумал, что хорошо бы сделать это поле списком, из котрого можно выбирать, и оставил его как обычное текстовое поле. Теперь у вас в данных есть «бакалавриат», «Бакалавриат» и какой-нибудь «БАкалавриат», то вообще-то одно и то же. Напасти подобного рода можно победить, если привести строки к единому регистру:

str_to_lower(c("Бакалавриат", "БАКАЛАВРИАТ", "АСпирантура", "магистратура"))
## [1] "бакалавриат"  "бакалавриат"  "аспирантура"  "магистратура"
str_to_upper(c("Бакалавриат", "БАКАЛАВРИАТ", "АСпирантура", "магистратура"))
## [1] "БАКАЛАВРИАТ"  "БАКАЛАВРИАТ"  "АСПИРАНТУРА"  "МАГИСТРАТУРА"
Но при таком способе сбора данных могли возникнуть и другие ошибки, так что лучше задуматься об их предотвращении заранее!

Поиск подстроки
Если нам надо найти какую-то подстроку, то мы можем использоваться функцию str_detect():

str_detect(unsorted_s, 'b') # ищем все элементы, в которых есть маленькая «b»
##  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [25] FALSE FALSE
unsorted_s[str_detect(unsorted_s, 'b')] # а вот и сами элементы
## [1] "Xbz" "Vmb"
Можно подсчитать число вхождений подстроки в строке:

str_count(unsorted_s, 'a')
##  [1] 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
Изменение строк
Раз мы умеем искать подстроку, то, наверное, её можно и как-то изменять.

Выделение подстроки
str_sub(unsorted_s, start = 1, end = 2) # по индексам
##  [1] "Xb" "Aj" "Yw" "Yl" "Si" "Qa" "Nz" "Nt" "Ok" "Fn" "Xs" "Ox" "Kp" "Er" "Py"
## [16] "Qv" "Vf" "Qe" "Rq" "Bu" "Fg" "Vm" "Fc" "Fh" "Td" "Oo"
Замена подстроки
str_replace(unsorted_s, pattern = "b", replacement = "Ц")
##  [1] "XЦz" "Aja" "Ywe" "Ylc" "Siv" "Qam" "Nzk" "Ntq" "Okd" "Fnt" "Xsy" "Oxi"
## [13] "Kpp" "Eru" "Pyl" "Qvn" "Vfr" "Qes" "Rqo" "Buh" "Fgj" "VmЦ" "Fcw" "Fhf"
## [25] "Tdx" "Oog"
Удаление подстроки
str_remove(unsorted_s, 'b')
##  [1] "Xz"  "Aja" "Ywe" "Ylc" "Siv" "Qam" "Nzk" "Ntq" "Okd" "Fnt" "Xsy" "Oxi"
## [13] "Kpp" "Eru" "Pyl" "Qvn" "Vfr" "Qes" "Rqo" "Buh" "Fgj" "Vm"  "Fcw" "Fhf"
## [25] "Tdx" "Oog"
Транслитерация строк
stri_trans_general("русский текст, который должен быть написан латиницей",
                   'cyrillic-latin')
## [1] "russkij tekst, kotoryj dolžen bytʹ napisan latinicej"
Регулярные выражения
Но часто нас интересует не конкретная подстрока, и все варианты подстрок, которые имеют определенную структуру. Например, мы хотим найти корректно введенные даты рождения в нашем датасете. Пусть по условию дата должна иметь формат DD.MM.YYYY. И у нас есть вот такой вектор:

dates <- c('21.92.2001', '01.04.1994', '5-3-2011', '6/04/1999')
Ну, так как у нас сейчас совсем игрушечные данные, мы можем смотреть на них глазами и видеть, что у нас в прицнипе три адекватные даты, но записаны по-разному, и одна верного формата, но с 92 месяцем.

Чтобы задать структуру паттерна, который мы хотим найти, используются регулярные выражения.

Чтобы отображать их работу, будем пользоваться функцией str_view_all().

Метасимволы
Если мы попробуем поискать точки в наших датах, то просто так мы их не найдем:

str_view_all(dates, pattern = ".")
21.92.2001
01.04.1994
5-3-2011
6/04/1999
Подсветились все символы, так как точка в регулярных выражениях — специальный символ. Поэтому чтобы указать, что нас интересуют собственно точки, нужно их экранировать.

str_view_all(dates, pattern = '\\.')
21.92.2001
01.04.1994
5-3-2011
6/04/1999
Так лучше. Еще к специальным знакам (метасимфолам) относятся $, *, +, ?, ^, [, ], и другие.

Классы знаков
В датах нас интересуют цифры, и для них есть специальное обозначение:

str_view_all(dates, pattern = '\\d') # ищем цифры
21.92.2001
01.04.1994
5-3-2011
6/04/1999
str_view_all(dates, pattern = '\\D') # ищем не-цифры
21.92.2001
01.04.1994
5-3-2011
6/04/1999
Другие классы символов можно найти в следующих примерах:

str_view_all('успешный балбес', '\\s') # пробелы
успешный балбес
str_view_all('успешный балбес', '\\S') # не-пробелы
успешный балбес
str_view_all('верно ведь, что здесь что-то есть', '\\w') # не пробелы и не знаки препинания
верно ведь, что здесь что-то есть
str_view_all('верно ведь, что здесь что-то есть', '\\W') # пробелы и знаки препинания
верно ведь, что здесь что-то есть
Квантификация
Можно указать, сколько раз должен встречаться тот или иной символ:

? — ноль или один раз
* — ноль или более раз
+ — один или более раз
{n} — n раз
Например, найдем все группировки по два числа:

str_view_all(dates, '\\d{2}')
21.92.2001
01.04.1994
5-3-2011
6/04/1999
Итак, теперь мы можем вытащить все корректные даты, которые есть в нашем векторе:

str_view_all(dates, '\\d{2}\\.[01]\\d{1}\\.\\d{4}')
21.92.2001
01.04.1994
5-3-2011
6/04/1999
Она получилась всего одна. Но в целом в нашим набором условий это справедливо.

Работа с реальными данными
Работу с реальными данными мы будем обсуждать в ходе курса. Сейчас же я хочу, чтобы вы попробовали выполнить саму первую задачу при работе с данными — чтение данных. Это первое, где можно существенно встрять и с чем надо уметь разбираться. Мы будем тренироваться на данных о фильмах и сериалах Netflix.

Импорт данных
Окей, файл с данными у нас есть. Теперь наша задача его как-то загрузить в R, чтобы мы могли с ним работать. Вариантов существует несколько. Разберём сначала следующий.

переложите скачанный файл из «Загрузок» в папку data
обратите внимание на расширение этого файла: netflix_title.csv
Такие файлы можно прочитать с помощью функции read.csv(). В аргументах это функции надо указать файл, который надо прочитать (а также путь к нему, начиная с подпапки рабочей директории). То есть:

netflix <- read.csv('data/netflix_titles.csv')
Почему так? Так как мы установили рабочую директорию (или запустили проект), то R по умолчанию теперь смотрит в папку нашего курса. А вот далее его надо сориентировать — поэтому мы пишем data/netflix_titles.csv. То есть говорим ему: «иди дальше в папку data и принеси мне файл netflix_titles.csv. Собственно, он нам его и принёс.

Можно это проверить:

head(netflix)
##   show_id    type title          director
## 1      s1 TV Show    3%                  
## 2      s2   Movie  7:19 Jorge Michel Grau
## 3      s3   Movie 23:59      Gilbert Chan
## 4      s4   Movie     9       Shane Acker
## 5      s5   Movie    21    Robert Luketic
## 6      s6 TV Show    46       Serdar Akar
##                                                                                                                                                                         cast
## 1 João Miguel, Bianca Comparato, Michel Gomes, Rodolfo Valente, Vaneza Oliveira, Rafael Lozano, Viviane Porto, Mel Fronckowiak, Sergio Mamberti, Zezé Motta, Celso Frateschi
## 2                                                                                   Demián Bichir, Héctor Bonilla, Oscar Serrano, Azalia Ortiz, Octavio Michel, Carmen Beato
## 3                                                               Tedd Chan, Stella Chung, Henley Hii, Lawrence Koh, Tommy Kuan, Josh Lai, Mark Lee, Susan Leong, Benjamin Lim
## 4                            Elijah Wood, John C. Reilly, Jennifer Connelly, Christopher Plummer, Crispin Glover, Martin Landau, Fred Tatasciore, Alan Oppenheimer, Tom Kane
## 5            Jim Sturgess, Kevin Spacey, Kate Bosworth, Aaron Yoo, Liza Lapira, Jacob Pitts, Laurence Fishburne, Jack McGee, Josh Gad, Sam Golzari, Helen Carey, Jack Gilpin
## 6                            Erdal Beşikçioğlu, Yasemin Allen, Melis Birkan, Saygın Soysal, Berkan Şal, Metin Belgin, Ayça Eren, Selin Uludoğan, Özay Fecht, Suna Yıldızoğlu
##         country        date_added release_year rating  duration
## 1        Brazil   August 14, 2020         2020  TV-MA 4 Seasons
## 2        Mexico December 23, 2016         2016  TV-MA    93 min
## 3     Singapore December 20, 2018         2011      R    78 min
## 4 United States November 16, 2017         2009  PG-13    80 min
## 5 United States   January 1, 2020         2008  PG-13   123 min
## 6        Turkey      July 1, 2017         2016  TV-MA  1 Season
##                                                  listed_in
## 1   International TV Shows, TV Dramas, TV Sci-Fi & Fantasy
## 2                             Dramas, International Movies
## 3                      Horror Movies, International Movies
## 4 Action & Adventure, Independent Movies, Sci-Fi & Fantasy
## 5                                                   Dramas
## 6          International TV Shows, TV Dramas, TV Mysteries
##                                                                                                                                             description
## 1              In a future where the elite inhabit an island paradise far from the crowded slums, you get one chance to join the 3% saved from squalor.
## 2  After a devastating earthquake hits Mexico City, trapped survivors from all walks of life wait to be rescued while trying desperately to stay alive.
## 3 When an army recruit is found dead, his fellow soldiers are forced to confront a terrifying secret that's haunting their jungle island training camp.
## 4     In a postapocalyptic world, rag-doll robots hide in fear from dangerous machines out to exterminate them, until a brave newcomer joins the group.
## 5       A brilliant group of students become card-counting experts with the intent of swindling millions out of Las Vegas casinos by playing blackjack.
## 6 A genetics professor experiments with a treatment for his comatose sister that blends medical and shamanic cures, but unlocks a shocking side effect.
Что-то загрузилось. Это хорошо. Что именно — выясним чуть позже.

Можно ли не прописывать data? Можно, но тогда придётся переложить файл данных в рабочую директорию (то есть папку курса). С одним файлом ничего, можно жить. А есть у вас 30 или 50 файлов разных респондентов? Уже тяжеловато и бардак. Поэтому, на мой взгляд, такая организация — хороший компромисс: кода пишем чуть-чуть больше, но зато есть порядок.

Конечно, можно хранить файлы данных где-то совсем отдельно. Но тогда и прописывать придётся путь от конревой папки компа:

# например, можно прочитать файл прямо из папки «Загрузки»
netflix <- read.csv('/Users/antonangelgardt/Downloads/netflix_titles.csv')
Это выглядит не очень удобно.

На самом деле, в мире облачных технологий можно и вовсе обойтись без скачивания файлов на десктоп. Функция read.csv() вполне может прочитать файл прямо из интернета:

# это ссылка на мой GitHub, где лежит нужный нам файл
netflix <- read.csv('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/data/netflix_titles.csv')
Однако стоит помнить, что наши собранные руками данные в облаках, скорее всего, не лежат. Поэтому надо уметь загрузить файл и из интернета, и с компа.

Форматы данных
Мы тактично соскользнули с момента расширения файла. Напомню, что у нас файл netflix_titles.csv. Пришло время уделить этому внимание.

Мы говорили о типах данных, о структурах данных — а теперь поговорим о форматах данных.

Формат данных — это характеристика данных, которая определяет много чего:

какие программы могут работать с этим файлом
как структурирован файл внутри
как структурированный файл разбирается на неструктирированные последовательности байтов (для хранения в памяти компьютера) и преобразуются обратно…
Ну, короче куча-куча всего. Формат файла (не вдаваясь в детали) задаётся его разширением, то есть тем, что написано после точки в его названии (.R, .doc, .xlsx, .xml, .txt, …).

Нас, прежде всего, интересуют файлы данных, поэтому об их форматах мы и поговорим.

Текстовые форматы
Проще всего хранить данные в тексте. Это удобно, такие файлы мало весят и в них можно поместить большое количество информации. Самый простой текстовый формат — это .txt. Это тот самый «Блокнот», с которым наверняка когда-то все сталкивались. Никакого форматирования, никакой лишней мишуры — только текст. Но нам ведь нужно из этого текста каким-то образом потом вытащить датафрейм. Для этого существуют разделители. Чаще всего в табличных .txt формате столбцы таблицы разделены между собой символами табуляции ('\tab'), а строки — символом переноса строки ('\n'). Файл .txt. можно считать с помощью функции read.table():

df <- read.table('data/text_data.txt') # это данные про качесво красного вина
# так как у вас нет отдельно скачанного этого датасета, то запустите вот эту команду, чтобы прочитать текстовый файл
# read.table() тоже умеет читать прямо из интернета
df <- read.table('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/text_data.txt')
Если использовать другие разделители, например, запятую, то получится файл, содержащий значения, разделённые запятыми (comma separated values). Это и есть .csv-файлы, с которыми мы будем чаще всего работать.

Несмотря на то, что по умолчанию операционная система пытается открыть CSV-шки в табличном редакторе (например, Excel), не надо на это вестись! CSV — это текстовый формат данных.

По умолчанию, в CSV-файле столбцы разделяются запятыми, а строки — символом переноса строки, поэтому функция read.csv() имеет соответствующие дефолтные настройки. Однако так бывает не всегда. Например, попробуем прочесть следующий файл:

# снова про качество вина
wine <- read.csv('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/winequality-red.csv')
Файл CSV-шный. Посмотрим, что получилось:

head(wine) # команда выводит часть датасета в консоль
##   fixed.acidity.volatile.acidity.citric.acid.residual.sugar.chlorides.free.sulfur.dioxide.total.sulfur.dioxide.density.pH.sulphates.alcohol.quality
## 1                                                                                                  7.4;0.7;0;1.9;0.076;11;34;0.9978;3.51;0.56;9.4;5
## 2                                                                                                  7.8;0.88;0;2.6;0.098;25;67;0.9968;3.2;0.68;9.8;5
## 3                                                                                               7.8;0.76;0.04;2.3;0.092;15;54;0.997;3.26;0.65;9.8;5
## 4                                                                                              11.2;0.28;0.56;1.9;0.075;17;60;0.998;3.16;0.58;9.8;6
## 5                                                                                                  7.4;0.7;0;1.9;0.076;11;34;0.9978;3.51;0.56;9.4;5
## 6                                                                                                 7.4;0.66;0;1.8;0.075;13;40;0.9978;3.51;0.56;9.4;5
Что-то получилось. Но мы хотели увидеть нечто, напоминающее таблицу (вернее, датафрейм), а получилось явно что-то не то… Почему так? Потому что расширение .csv ещё не гарант того, что в файле в качестве разделителя использовалась запятая. Глобально — это может быть вообще любой знак. В данном случае была использована точка с запятой. Если мы немного изменим команду и вручную укажем разделитель (separator), то всё будет ок:

wine <- read.csv('https://raw.githubusercontent.com/angelgardt/hseuxlab-wlm2021/master/book/wlm2021-book/data/winequality-red.csv',
                 sep = ';')
head(wine)
##   fixed.acidity volatile.acidity citric.acid residual.sugar chlorides
## 1           7.4             0.70        0.00            1.9     0.076
## 2           7.8             0.88        0.00            2.6     0.098
## 3           7.8             0.76        0.04            2.3     0.092
## 4          11.2             0.28        0.56            1.9     0.075
## 5           7.4             0.70        0.00            1.9     0.076
## 6           7.4             0.66        0.00            1.8     0.075
##   free.sulfur.dioxide total.sulfur.dioxide density   pH sulphates alcohol
## 1                  11                   34  0.9978 3.51      0.56     9.4
## 2                  25                   67  0.9968 3.20      0.68     9.8
## 3                  15                   54  0.9970 3.26      0.65     9.8
## 4                  17                   60  0.9980 3.16      0.58     9.8
## 5                  11                   34  0.9978 3.51      0.56     9.4
## 6                  13                   40  0.9978 3.51      0.56     9.4
##   quality
## 1       5
## 2       5
## 3       5
## 4       6
## 5       5
## 6       5
Вот теперь хорошо.

Табличные форматы
Данные могут храниться и в табличных форматах — это привычные нам Excel-таблицы с расширениями .xls и .xlsx. Поскольку это уже не текст, а именно таблица, то и вопросов с разделителями здесь не возникает. Однако, как мы знаем, Excel books могут состоять из нескольких листов, и данные могут располагаться на любом из них, хотя, конечно, чаще всего они располагаются на первом листе. Функций для импорта табличных данных существует несколько, я предлагаю вам вот эту:

df <- readxl::read_excel('path/to/file.xlsx', sheet = 2)
Здесь мы уже привычно задаем в качестве первого аргумента путь к файлу, а вторым (опциональным) аргументом можно указать номер листа, с которого нужно считать данные. По умолчанию этот аргумент равен 1
.

Заметьте ещё одну особенность обращения к функциям из внешних пакетов. Если нам нужна только одна функция из пакета, то не обязательно погружать весь пакет к сессии через функцию library(). Можно указать название пакета9, из которого нам нужна функция, далее поставить два двоеточия10 и затем использовать функцию, которая нам нужна.

Форматы данных с особой разметкой
Есть и более экзотичные персонажи в мире форматов данных. Таковы, например, .json и .xml. Они главным образом заточены под передачу даных в интернете, поэтому если мы не соприкасаетесь с данной областью напрямую, то, скорее всего, не столкнетесь с ними никогда. Однако для общего представления будет полезно знать о том, что такие звери существуют.

Как импортируется JSON можно посмотреть тут, а про XML есть здесь.

Файлы данных других статистических программ
В нашей исследовательской области всё ещё остаются активно распространены другие статистические программы, например, SPSS. И вы вполне можете столкнуться с необходимостью чтения данных из файлов формата .sav — это специальные файлы данных программы SPSS. В целом, в них нет чего-либо супернеобычного, однако есть некоторые особенности.

Для их чтения потребуется пакет foreign11:

df <- foreign::read.spss('path/to/file.sav',
                         use.value.labels = TRUE,
                         to.data.frame = TRUE,
                         use.missings = TRUE)
Из всего пакета нам снова нужна только одна функция, которая импортирует файлы .sav. Можно наблюдать, что она хочет ряд дополнительных аргументов. Они не обязательные, но чтобы быть уверенным в корректном импорте, лучше их прописать. use.value.labels определяет загрузку факторным переменных, to.data.frame говорит, что мы хотим получить на выходе датафрейм (если указать FALSE, то будет список), use.missings означает, что вместо пропусков будут указаны NA (а нам это надо).

Исследование данных
Мы вдоволь наговорились о форматах данных. Теперь попробуем поработать с тем, что у нас есть. Напомню, что мы загрузили данные о фильмах и сериалах Netflix в переменную netflix.

Когда мы загрузили датасет, нам, прежде всего, хочется посмотреть, как оно выглядит. Это можно сделать несколькими способами. Если мы хотим более привычный для неискущённого пользователя вариант, то можно воспользоваться командой View() (именно с заглавной):

View(netflix)
В соседней вкладке откроется датасет в привычном табличном виде, и можно будет посмотреть, корректно ли прочитались данные. Вариант удобный, но если у вас датасет в 1000 строк, «отсматривать глазами» косяки чтения данных совершенно бессмысленно.

Можно вывести первые несколько строк датасета в консоль — это мы уже делали:

head(netflix)
##   show_id    type title          director
## 1      s1 TV Show    3%                  
## 2      s2   Movie  7:19 Jorge Michel Grau
## 3      s3   Movie 23:59      Gilbert Chan
## 4      s4   Movie     9       Shane Acker
## 5      s5   Movie    21    Robert Luketic
## 6      s6 TV Show    46       Serdar Akar
##                                                                                                                                                                         cast
## 1 João Miguel, Bianca Comparato, Michel Gomes, Rodolfo Valente, Vaneza Oliveira, Rafael Lozano, Viviane Porto, Mel Fronckowiak, Sergio Mamberti, Zezé Motta, Celso Frateschi
## 2                                                                                   Demián Bichir, Héctor Bonilla, Oscar Serrano, Azalia Ortiz, Octavio Michel, Carmen Beato
## 3                                                               Tedd Chan, Stella Chung, Henley Hii, Lawrence Koh, Tommy Kuan, Josh Lai, Mark Lee, Susan Leong, Benjamin Lim
## 4                            Elijah Wood, John C. Reilly, Jennifer Connelly, Christopher Plummer, Crispin Glover, Martin Landau, Fred Tatasciore, Alan Oppenheimer, Tom Kane
## 5            Jim Sturgess, Kevin Spacey, Kate Bosworth, Aaron Yoo, Liza Lapira, Jacob Pitts, Laurence Fishburne, Jack McGee, Josh Gad, Sam Golzari, Helen Carey, Jack Gilpin
## 6                            Erdal Beşikçioğlu, Yasemin Allen, Melis Birkan, Saygın Soysal, Berkan Şal, Metin Belgin, Ayça Eren, Selin Uludoğan, Özay Fecht, Suna Yıldızoğlu
##         country        date_added release_year rating  duration
## 1        Brazil   August 14, 2020         2020  TV-MA 4 Seasons
## 2        Mexico December 23, 2016         2016  TV-MA    93 min
## 3     Singapore December 20, 2018         2011      R    78 min
## 4 United States November 16, 2017         2009  PG-13    80 min
## 5 United States   January 1, 2020         2008  PG-13   123 min
## 6        Turkey      July 1, 2017         2016  TV-MA  1 Season
##                                                  listed_in
## 1   International TV Shows, TV Dramas, TV Sci-Fi & Fantasy
## 2                             Dramas, International Movies
## 3                      Horror Movies, International Movies
## 4 Action & Adventure, Independent Movies, Sci-Fi & Fantasy
## 5                                                   Dramas
## 6          International TV Shows, TV Dramas, TV Mysteries
##                                                                                                                                             description
## 1              In a future where the elite inhabit an island paradise far from the crowded slums, you get one chance to join the 3% saved from squalor.
## 2  After a devastating earthquake hits Mexico City, trapped survivors from all walks of life wait to be rescued while trying desperately to stay alive.
## 3 When an army recruit is found dead, his fellow soldiers are forced to confront a terrifying secret that's haunting their jungle island training camp.
## 4     In a postapocalyptic world, rag-doll robots hide in fear from dangerous machines out to exterminate them, until a brave newcomer joins the group.
## 5       A brilliant group of students become card-counting experts with the intent of swindling millions out of Las Vegas casinos by playing blackjack.
## 6 A genetics professor experiments with a treatment for his comatose sister that blends medical and shamanic cures, but unlocks a shocking side effect.
По умолчанию выводится шесть строк, однако этот парамент можно задать вручную:

head(netflix, n = 4)
##   show_id    type title          director
## 1      s1 TV Show    3%                  
## 2      s2   Movie  7:19 Jorge Michel Grau
## 3      s3   Movie 23:59      Gilbert Chan
## 4      s4   Movie     9       Shane Acker
##                                                                                                                                                                         cast
## 1 João Miguel, Bianca Comparato, Michel Gomes, Rodolfo Valente, Vaneza Oliveira, Rafael Lozano, Viviane Porto, Mel Fronckowiak, Sergio Mamberti, Zezé Motta, Celso Frateschi
## 2                                                                                   Demián Bichir, Héctor Bonilla, Oscar Serrano, Azalia Ortiz, Octavio Michel, Carmen Beato
## 3                                                               Tedd Chan, Stella Chung, Henley Hii, Lawrence Koh, Tommy Kuan, Josh Lai, Mark Lee, Susan Leong, Benjamin Lim
## 4                            Elijah Wood, John C. Reilly, Jennifer Connelly, Christopher Plummer, Crispin Glover, Martin Landau, Fred Tatasciore, Alan Oppenheimer, Tom Kane
##         country        date_added release_year rating  duration
## 1        Brazil   August 14, 2020         2020  TV-MA 4 Seasons
## 2        Mexico December 23, 2016         2016  TV-MA    93 min
## 3     Singapore December 20, 2018         2011      R    78 min
## 4 United States November 16, 2017         2009  PG-13    80 min
##                                                  listed_in
## 1   International TV Shows, TV Dramas, TV Sci-Fi & Fantasy
## 2                             Dramas, International Movies
## 3                      Horror Movies, International Movies
## 4 Action & Adventure, Independent Movies, Sci-Fi & Fantasy
##                                                                                                                                             description
## 1              In a future where the elite inhabit an island paradise far from the crowded slums, you get one chance to join the 3% saved from squalor.
## 2  After a devastating earthquake hits Mexico City, trapped survivors from all walks of life wait to be rescued while trying desperately to stay alive.
## 3 When an army recruit is found dead, his fellow soldiers are forced to confront a terrifying secret that's haunting their jungle island training camp.
## 4     In a postapocalyptic world, rag-doll robots hide in fear from dangerous machines out to exterminate them, until a brave newcomer joins the group.
Аналогично можно вывести несколько последних строк:

tail(netflix, n = 9)
##      show_id    type                                   title        director
## 7779   s7779   Movie                              Zombieland Ruben Fleischer
## 7780   s7780 TV Show                               Zona Rosa                
## 7781   s7781   Movie                                     Zoo    Shlok Sharma
## 7782   s7782   Movie                                    Zoom    Peter Hewitt
## 7783   s7783   Movie                                    Zozo     Josef Fares
## 7784   s7784   Movie                                  Zubaan     Mozez Singh
## 7785   s7785   Movie                       Zulu Man in Japan                
## 7786   s7786 TV Show                   Zumbo's Just Desserts                
## 7787   s7787   Movie ZZ TOP: THAT LITTLE OL' BAND FROM TEXAS        Sam Dunn
##                                                                                                                                       cast
## 7779                                   Jesse Eisenberg, Woody Harrelson, Emma Stone, Abigail Breslin, Amber Heard, Bill Murray, Derek Graf
## 7780                                                                                  Manu NNa, Ana Julia Yeyé, Ray Contreras, Pablo Morán
## 7781                                             Shashank Arora, Shweta Tripathi, Rahul Kumar, Gopal K. Singh, Yogesh Kurme, Prince Daniel
## 7782               Tim Allen, Courteney Cox, Chevy Chase, Kate Mara, Ryan Newman, Michael Cassidy, Spencer Breslin, Rip Torn, Kevin Zegers
## 7783                             Imad Creidi, Antoinette Turk, Elias Gergi, Carmen Lebbos, Viktor Axelsson, Charbel Iskandar, Yasmine Awad
## 7784 Vicky Kaushal, Sarah-Jane Dias, Raaghav Chanana, Manish Chaudhary, Meghna Malik, Malkeet Rauni, Anita Shabdish, Chittaranjan Tripathy
## 7785                                                                                                                               Nasty C
## 7786                                                                                                            Adriano Zumbo, Rachel Khoo
## 7787                                                                                                                                      
##                                                           country
## 7779                                                United States
## 7780                                                       Mexico
## 7781                                                        India
## 7782                                                United States
## 7783 Sweden, Czech Republic, United Kingdom, Denmark, Netherlands
## 7784                                                        India
## 7785                                                             
## 7786                                                    Australia
## 7787                        United Kingdom, Canada, United States
##              date_added release_year rating duration
## 7779   November 1, 2019         2009      R   88 min
## 7780  November 26, 2019         2019  TV-MA 1 Season
## 7781       July 1, 2018         2018  TV-MA   94 min
## 7782   January 11, 2020         2006     PG   88 min
## 7783   October 19, 2020         2005  TV-MA   99 min
## 7784      March 2, 2019         2015  TV-14  111 min
## 7785 September 25, 2020         2019  TV-MA   44 min
## 7786   October 31, 2020         2019  TV-PG 1 Season
## 7787      March 1, 2020         2019  TV-MA   90 min
##                                                                            listed_in
## 7779                                                         Comedies, Horror Movies
## 7780 International TV Shows, Spanish-Language TV Shows, Stand-Up Comedy & Talk Shows
## 7781                                Dramas, Independent Movies, International Movies
## 7782                                              Children & Family Movies, Comedies
## 7783                                                    Dramas, International Movies
## 7784                                  Dramas, International Movies, Music & Musicals
## 7785                           Documentaries, International Movies, Music & Musicals
## 7786                                              International TV Shows, Reality TV
## 7787                                                 Documentaries, Music & Musicals
##                                                                                                                                                 description
## 7779              Looking to survive in a world taken over by zombies, a dorky college student teams with an urban roughneck and a pair of grifter sisters.
## 7780                            An assortment of talent takes the stage for a night of honest stand-up featuring four of Mexico's funniest LGBTQ comedians.
## 7781 A drug dealer starts having doubts about his trade as his brother, his client, and two rappers from the slums each battle their own secret addictions.
## 7782  Dragged from civilian life, a former superhero must train a new crop of youthful saviors when the military preps for an attack by a familiar villain.
## 7783     When Lebanon's Civil War deprives Zozo of his family, he's left with grief and little means as he escapes to Sweden in search of his grandparents.
## 7784                A scrappy but poor boy worms his way into a tycoon's dysfunctional family, while facing his fear of music and the truth about his past.
## 7785   In this documentary, South African rapper Nasty C hits the stage and streets of Tokyo, introducing himself to the city's sights, sounds and culture.
## 7786    Dessert wizard Adriano Zumbo looks for the next “Willy Wonka” in this tense competition that finds skilled amateurs competing for a $100,000 prize.
## 7787          This documentary delves into the mystique behind the blues-rock trio and explores how the enigmatic band created their iconic look and sound.
Но мы помним, что датафрейм — это список. А на списках работала функция str(), которая показывала структуру списка. Значит, можно выполнить эту функцию и на датафрейме? Да!

str(netflix)
## 'data.frame':    7787 obs. of  12 variables:
##  $ show_id     : chr  "s1" "s2" "s3" "s4" ...
##  $ type        : chr  "TV Show" "Movie" "Movie" "Movie" ...
##  $ title       : chr  "3%" "7:19" "23:59" "9" ...
##  $ director    : chr  "" "Jorge Michel Grau" "Gilbert Chan" "Shane Acker" ...
##  $ cast        : chr  "João Miguel, Bianca Comparato, Michel Gomes, Rodolfo Valente, Vaneza Oliveira, Rafael Lozano, Viviane Porto, Me"| __truncated__ "Demián Bichir, Héctor Bonilla, Oscar Serrano, Azalia Ortiz, Octavio Michel, Carmen Beato" "Tedd Chan, Stella Chung, Henley Hii, Lawrence Koh, Tommy Kuan, Josh Lai, Mark Lee, Susan Leong, Benjamin Lim" "Elijah Wood, John C. Reilly, Jennifer Connelly, Christopher Plummer, Crispin Glover, Martin Landau, Fred Tatasc"| __truncated__ ...
##  $ country     : chr  "Brazil" "Mexico" "Singapore" "United States" ...
##  $ date_added  : chr  "August 14, 2020" "December 23, 2016" "December 20, 2018" "November 16, 2017" ...
##  $ release_year: int  2020 2016 2011 2009 2008 2016 2019 1997 2019 2008 ...
##  $ rating      : chr  "TV-MA" "TV-MA" "R" "PG-13" ...
##  $ duration    : chr  "4 Seasons" "93 min" "78 min" "80 min" ...
##  $ listed_in   : chr  "International TV Shows, TV Dramas, TV Sci-Fi & Fantasy" "Dramas, International Movies" "Horror Movies, International Movies" "Action & Adventure, Independent Movies, Sci-Fi & Fantasy" ...
##  $ description : chr  "In a future where the elite inhabit an island paradise far from the crowded slums, you get one chance to join t"| __truncated__ "After a devastating earthquake hits Mexico City, trapped survivors from all walks of life wait to be rescued wh"| __truncated__ "When an army recruit is found dead, his fellow soldiers are forced to confront a terrifying secret that's haunt"| __truncated__ "In a postapocalyptic world, rag-doll robots hide in fear from dangerous machines out to exterminate them, until"| __truncated__ ...
Тут даже попроще аутпут. Функция выводит структуру датафрейма, в которой отображены количество наблюдений (строк) и количество переменных (столбцов), сами переменные, в нём содержащиеся, их тип, а также первые несколько значений каждой переменной. Это позволяет составить общее представление о том, что есть в наших данных.

Есть ещё одна полезная функция, чтобы понять, всё ли ок с данными:

summary(netflix)
##    show_id              type              title             director        
##  Length:7787        Length:7787        Length:7787        Length:7787       
##  Class :character   Class :character   Class :character   Class :character  
##  Mode  :character   Mode  :character   Mode  :character   Mode  :character  
##                                                                             
##                                                                             
##                                                                             
##      cast             country           date_added         release_year 
##  Length:7787        Length:7787        Length:7787        Min.   :1925  
##  Class :character   Class :character   Class :character   1st Qu.:2013  
##  Mode  :character   Mode  :character   Mode  :character   Median :2017  
##                                                           Mean   :2014  
##                                                           3rd Qu.:2018  
##                                                           Max.   :2021  
##     rating            duration          listed_in         description       
##  Length:7787        Length:7787        Length:7787        Length:7787       
##  Class :character   Class :character   Class :character   Class :character  
##  Mode  :character   Mode  :character   Mode  :character   Mode  :character  
##                                                                             
##                                                                             
## 
Эта функция выводит «саммари» (неужели!) по каждой из переменных датасета. Если переменная числовая, то выводятся базовые описательные статистики (например, как в случае release_year). Наш же датасет оказался богат на строковые переменные, для которых summary() может посчитать только количество наблюдений и указать класс (тип) переменной.

В целом, этого достаточно, чтобы базово проверить, верно ли прочитались данные. А далее нас ждет интересное путешествие в их предобработку и статистический анализ!

Файл .RData
Ну, и на последнок нечто, что может вам в определенные моменты облегчить жизнь.

Часто возникает потребность сохранить наработки, когда работа ещё не завершена. Допустим, у вас в Environment накопилась дикая куча объектов, с которыми вы работаете — датафреймы, матрицы, вектора, списки результатов работы статистических функций… — и хотелось бы как-то это все положить на полку, чтобы в следующий раз не перезапускать все 100500 строк кода, которыми вы это множество объектов получили.

Такая возможность есть. Для этого вам нужно сохранить образ вашего Environment. Это делается с помошью функции save.image():

save.image('netflix.RData')
В аргументе функции мы указваем название файла, в котором будет лежать этот образ. Файл имеет расширение .RData. Можно прописать какой-либо путь к другому месту на компьютере, но в целом можно и оставить в рабочей директории. Когда понадобится продолжить работу, его будет нужно подгрузить с помощью функции load(),

load('netflix.RData')
и продолжать работу с той строки скрипта, на которой вы остановились. Все созданные ранее объекты уже будут в Environment.

При завершении сессии в R он может предложить вам сохранить файл .RData. Не советую это делать — лучше сохранять образ Environment вручную, чтобы знать, что там лежит. Если сохранить файл .RData при выходе по предложению R, то, во-первых, его будет сложно достать, потому что он будет не видим невооруженным глазом в директории (сохраняется как скрытый файл), а во-вторых, он может подгрузиться тогда, когда вы его не просили и сломать вам весь кайф. Придётся числить Environment, прогонять заново код — а оно нам надо? Кажется, нет!

При первом запуске может не быть окна Code Editor. Чтобы его открыть, сделайте File → New File → R Script или нажмите Ctrl + Shift + N (⌘ + Shift + N).↩︎

Чтобы не возникало лишних вопросов, лучше снабдить папку с файлами документом README.md, где описать все важные детали, в том числе и кодировку файла. Об это ещё немного поговорим поздее.↩︎

Бывает, что вот это распространяют и на калькуляторы тоже. [Кек]↩︎

А вообще в разных языках программирования этот вопрос решается по-разному.↩︎

Так-то любой оператор (арифметический или логический) — это функция от двух переменных. В предудщей главе был пример `+`(7, 3), а теперь попробуйте выполнить `&`(TRUE, FALSE).↩︎

Хотя, например, для JavaScript сложение строк — стандартная процедура.↩︎

Такие векторы называются свободными.↩︎

Ещё есть numeric() и logical(), например.↩︎

Пакет должен быть установлен (например, через install.packages()).↩︎

Два двоеточия — указание на обращение к определенному пространству имён. В данном случае пространство имён — синоним пакета, так как в разных пакетах могут содержаться функции с одинаковым названием (именем). Такое эксплицитное указание на пакет (пространство имён) также может понадобиться в случае, когда подгруженные функции из внешнего пакета конфликтуют с базовыми, хотя это достаточно редкая история.↩︎

Есть и другие, но этот достаточно прост и интуитивен, как по мне. В нём есть функции не только для чтения SPSS-ных файлов, а ещё куча-куча всего.↩︎

<!-- https://angelgardt.github.io/hse-rs-appandan-2023/r-intro -->
